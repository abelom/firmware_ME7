
! this file defines the format of rusEfi persistent configuration structure
! this file is processed by ../java_tools/config_definition.jar tool
! comments start with '!'
!
!
! rusEfi configuration consists of two parts:
! First part is engine_configuration_s area, followed by a few tuning tables
!
! The only difference her is that engine_configuration_s area does not support hot modification while tuning tables could
! be modified without burning changes
!
!
! See also ../tunerstudio/readme.txt
!
! Q: How to add new fields?
! A: Find an 'unused' bit or unused int (usually the huge unusedEnd[] array at the end
!    rename the bit or substitute unused integer with any new fields of the same size
!    invoke gen_config.bat to apply the tools which would generate .h and .ini files
!
!
! each field is declared as
! type name;comment


#define TS_SIGNATURE "rusEFI v1.08"
!
! this is used to confirm that firmware and TunerStudio are using the same rusefi.ini version
! so not forget to change fileVersion in rusefi.ini
! todo: is this not needed in light of TS_SIGNATURE?
#define TS_FILE_VERSION 20191221


! all the sub-structures are going to be nested within the primary structure, that's
! needed to get a proper TunerStudio file

! this section is auto-generated by FiringOrderTSLogic.java
#define ignitionPin2logic || ((firingOrder == 2) || (firingOrder == 7) || (firingOrder == 9) || (firingOrder == 11) || (firingOrder == 12))
#define ignitionPin3logic || ((firingOrder == 1) || (firingOrder == 3) || (firingOrder == 4) || (firingOrder == 5) || (firingOrder == 9))
#define ignitionPin4logic || ((firingOrder == 5) || (firingOrder == 7) || (firingOrder == 12))
#define ignitionPin5logic || ((firingOrder == 4) || (firingOrder == 12))
#define ignitionPin6logic 
#define ignitionPin7logic || ((firingOrder == 11))
#define ignitionPin8logic || ((firingOrder == 5) || (firingOrder == 11))
#define ignitionPin9logic 
#define ignitionPin10logic 
#define ignitionPin11logic 
#define ignitionPin12logic 

struct persistent_config_s 

struct_no_prefix engine_configuration_s

! todo there is still a spot where this 200 is hard-coded
#define LE_COMMAND_LENGTH 200

! see 'blockingFactor' in rusefi.ini
#define BLOCKING_FACTOR 400

#define FSIO_ANALOG_INPUT_COUNT 4

#define CAM_INPUTS_COUNT 4

#define SERVO_COUNT 8

#define CONSOLE_DATA_PROTOCOL_TAG " @"

#define ETB_BIAS_CURVE_LENGTH 8

! this is here so that rusEfi console can access it, too
#define TS_OUTPUT_SIZE 340

#define MAP_ANGLE_SIZE 8
#define MAP_WINDOW_SIZE 8

#define IAC_PID_MULT_SIZE 8

#define NARROW_BAND_WIDE_BAND_CONVERSION_SIZE 8
#define AFTERSTART_HOLD_CURVE_SIZE 8
#define AFTERSTART_DECAY_CURVE_SIZE 8
#define AFTERSTART_ENRICH_CURVE_SIZE 8
#define CLT_CURVE_SIZE 16
#define CRANKING_CLT_IDLE_CURVE_SIZE 8
#define CLT_CRANKING_CURVE_SIZE 8
#define IDLE_ADVANCE_CURVE_SIZE 8
#define CRANKING_ADVANCE_CURVE_SIZE 4

#define ENGINE_NOISE_CURVE_SIZE 8
#define CLT_TIMING_CURVE_SIZE 8
#define IDLE_VE_CURVE_SIZE 8

#define ETB_COUNT 2

#define AUX_DIGITAL_VALVE_COUNT 2

#define IAT_CURVE_SIZE 16

#define VBAT_INJECTOR_CURVE_SIZE 8

#define DWELL_CURVE_SIZE 8

#define CRANKING_CURVE_SIZE 8

#define IGN_LOAD_COUNT 16
#define IGN_TPS_COUNT 16
#define IGN_RPM_COUNT 16

#define INJECTION_PIN_COUNT 12
#define IGNITION_PIN_COUNT 12
#define EGT_CHANNEL_COUNT 8
#define DIGIPOT_COUNT 4
#define HW_MAX_ADC_INDEX 17
#define TRIGGER_SIMULATOR_PIN_COUNT 3
#define TRIGGER_INPUT_PIN_COUNT 3
#define LOGIC_ANALYZER_CHANNEL_COUNT 4
#define FSIO_COMMAND_COUNT 16
#define AUX_PID_COUNT 4

#define FUEL_RPM_COUNT 16
#define FUEL_LOAD_COUNT 16

#define BOOST_RPM_COUNT 8
#define BOOST_LOAD_COUNT 8
#define VVT_RPM_COUNT 8
#define VVT_LOAD_COUNT 8

#define PEDAL_TO_TPS_SIZE 8


! 
! all the xxx_PACKING_xxx constants are about persisting tables in compact for, for example packing RPM with 50 increment in a byte
! or packing numeric voltage inside an integer byte
! See usages of '@@RPM_1_BYTE_PACKING_MULT@@' where we apply the TS part of the magic
! 
#define RPM_1_BYTE_PACKING_MULT 50
#define VOLTAGE_1_BYTE_PACKING_DIV 0.02

! These are used currently only for output channels - but could be for config as well
#define PACK_MULT_PRESSURE 30
#define PACK_MULT_PERCENT 100
#define PACK_MULT_TEMPERATURE 100
#define PACK_MULT_MS 300
#define PACK_MULT_AFR 1000
#define PACK_MULT_ANGLE 50
#define PACK_MULT_VOLTAGE 1000
#define TPS_1_BYTE_PACKING_MULT 2
#define LOAD_1_BYTE_PACKING_MULT 2
#define FSIO_TABLE_8 8
#define GP_PWM_RPM_COUNT 8
#define GP_PWM_LOAD_COUNT 8
#define FSIO_CURVE_8 8
#define FSIO_CURVE_16 16

#define TPS_TPS_ACCEL_TABLE 8
#define MAP_ACCEL_TAPER 8

#define BARO_CORR_SIZE 4

#define MAF_DECODING_COUNT 256

custom fuel_table_t	4*@@FUEL_RPM_COUNT@@x@@FUEL_LOAD_COUNT@@ array,   F32,   @OFFSET@, [@@FUEL_RPM_COUNT@@x@@FUEL_LOAD_COUNT@@],"ms",      1,     0,      0.0,   500.0,   2
custom ve_table_t 4*@@FUEL_RPM_COUNT@@x@@FUEL_LOAD_COUNT@@ array,   F32,   @OFFSET@, [@@FUEL_RPM_COUNT@@x@@FUEL_LOAD_COUNT@@],"%", 1, 0, 0, 999.0, 2
custom afr_table_t @@FUEL_RPM_COUNT@@x@@FUEL_LOAD_COUNT@@ array,   U08,   @OFFSET@, [@@FUEL_RPM_COUNT@@x@@FUEL_LOAD_COUNT@@],"deg",	   0.1,     0,        0,  25.0,     1 

custom fsio_table_8x8_u8t	@@FSIO_TABLE_8@@x@@FSIO_TABLE_8@@ array,   U08,   @OFFSET@, [@@FSIO_TABLE_8@@x@@FSIO_TABLE_8@@],"value",      1,     0,      0.0,   255.0,   0
custom fsio_table_8x8_f32t	4*@@FSIO_TABLE_8@@x@@FSIO_TABLE_8@@ array,   F32,   @OFFSET@, [@@FSIO_TABLE_8@@x@@FSIO_TABLE_8@@],  { bitStringValue(vvtLoadUnits ,  vvtLoadAxis) },     1,       0,     -720,  720,    1
custom tps_tps_table_t	4*@@TPS_TPS_ACCEL_TABLE@@x@@TPS_TPS_ACCEL_TABLE@@ array,   F32,   @OFFSET@, [@@TPS_TPS_ACCEL_TABLE@@x@@TPS_TPS_ACCEL_TABLE@@],"value",      1,     0,      0.0,   30000.0,   2


custom baro_corr_table_t 4*@@BARO_CORR_SIZE@@x@@BARO_CORR_SIZE@@ array,   F32,   @OFFSET@, [@@BARO_CORR_SIZE@@x@@BARO_CORR_SIZE@@],"ratio", 1, 0, 0, 2.0, 2


custom ignition_table_t	4*@@IGN_RPM_COUNT@@x@@IGN_LOAD_COUNT@@ array,   F32,   @OFFSET@, [@@IGN_RPM_COUNT@@x@@IGN_LOAD_COUNT@@],"deg",	   1,     0,     -20, 90,    2
custom ignition_tps_table_t	2*@@IGN_RPM_COUNT@@x@@IGN_TPS_COUNT@@ array,   S16,   @OFFSET@, [@@IGN_RPM_COUNT@@x@@IGN_TPS_COUNT@@],"deg",	   0.01,     0,     -20, 90,    2

custom angle_table_t	4*@@IGN_RPM_COUNT@@x@@IGN_LOAD_COUNT@@ array,   F32,   @OFFSET@, [@@IGN_RPM_COUNT@@x@@IGN_LOAD_COUNT@@],"deg",	   1,     0,     -720,  720,    2
custom pedal_to_tps_t	@@PEDAL_TO_TPS_SIZE@@x@@PEDAL_TO_TPS_SIZE@@ array,   U08,   @OFFSET@, [@@PEDAL_TO_TPS_SIZE@@x@@PEDAL_TO_TPS_SIZE@@],"deg",	   1,     0,     -720,  720,    2

custom iac_pid_mult_t	@@IAC_PID_MULT_SIZE@@x@@IAC_PID_MULT_SIZE@@ array,   U08,   @OFFSET@, [@@IAC_PID_MULT_SIZE@@x@@IAC_PID_MULT_SIZE@@],"%",	   1,     0,     0,  999,    2
custom boost_table_t	@@BOOST_RPM_COUNT@@x@@BOOST_LOAD_COUNT@@ array,   U08,   @OFFSET@, [@@BOOST_RPM_COUNT@@x@@BOOST_LOAD_COUNT@@],"",    @@LOAD_1_BYTE_PACKING_MULT@@,  0 ,    0,    3000,      0
custom vvt_table_f32t	@@VVT_RPM_COUNT@@x@@VVT_LOAD_COUNT@@ array,   F32,   @OFFSET@, [@@VVT_RPM_COUNT@@x@@VVT_LOAD_COUNT@@],   { bitStringValue(vvtLoadUnits ,  vvtLoadAxis) },     1,       0,     -720,  720,    1
custom gp_pwm_table_t @@GP_PWM_RPM_COUNT@@x@@GP_PWM_LOAD_COUNT@@ array,   U08,   @OFFSET@, [@@GP_PWM_RPM_COUNT@@x@@GP_PWM_LOAD_COUNT@@],"value",      1,     0,      0.0,   30000.0,   2
struct pid_s
	float pFactor;;"",      1,      0,       -10000, 10000,      1
	float iFactor;;"",      1,      0,       -10000, 10000,      1
	float dFactor;;"",      1,      0,       -10000, 10000,      1
	int16_t fsio_visible offset;Linear addition to PID logic;"",      1,      0,       -1000, 1000,      0
	int16_t periodMs;PID dTime;"ms",      1,      0,       0, 3000,      0
	int16_t fsio_visible minValue;Output min value;"",        1,     0,  -30000,    30000.0,  0
	int16_t maxValue;Output max value;"",        1,     0,  -30000,    30000.0,  0
end_struct

#define ego_sensor_e_enum "BPSX", "Innovate", "14Point7", "Narrow", "PLX", "Custom"
custom ego_sensor_e 4 bits, S32, @OFFSET@, [0:7], @@ego_sensor_e_enum@@

struct cranking_parameters_s
float baseFuel;+Base duration of the fuel injection during cranking, this is modified by the multipliers for CLT, IAT, TPS ect, to give the final cranking pulse width.;"ms",       1,     0,    0, 200,     1
int16_t rpm;+This sets the RPM limit below which the ECU will use cranking fuel and ignition logic, typically this is around 350-450rpm. \nset cranking_rpm X;"RPM",      1,     0,    0, 3000,      0
end_struct

#define debug_mode_e_enum "Alternator PID", "TPS acceleration enrichment", "INVALID", "Idle Control", "Engine Load accl enrich", "Trigger Counters", "FSIO_ADC", "AUX_PID_1", "VVT input", "Cranking", "Timing", "Closed-loop fuel corr PID", "VSS", "SD card", "sr5", "Knock", "Trigger Sync", "Electronic Throttle", "Executor", "Bench Test / TS commands", "Aux Valves", "Analog inputs #1", "INSTANT_RPM", "FSIO_EXPRESSION", "Status", "CJ125", "CAN", "MAP", "Metrics", "ETB#2", "Ion Sense", "TLE8888", "Analog inputs #2", "Dwell Metric", "Aux Temperature", "ETB Logic", "Boost Control", "Launch Control"
custom debug_mode_e 4 bits,    U32,   @OFFSET@, [0:7], @@debug_mode_e_enum@@

#define vvt_mode_e_enum "First half", "Second half", "2GZ", "Miata NB2", "mode4", "mode5", "mode6", "mode7"
custom vvt_mode_e 4 bits,    U32,   @OFFSET@, [0:7], @@vvt_mode_e_enum@@

#define can_device_mode_e_enum "v0", "v1"
custom can_device_mode_e 4 bits,    U32,   @OFFSET@, [0:7], @@can_device_mode_e_enum@@

#define mass_storage_e_enum "Auto", "Always", "Never"
custom mass_storage_e 4 bits, U32, @OFFSET@, [0:7], @@mass_storage_e_enum@@

! At the moment TIM1, TIM2, TIM3 and TIM9 are configured as ICU
! todo: as of ChibiOS3, only channels 1 & 2 are allowed to capture input, that's a ChibiOS driver limitation
! https://github.com/ChibiOS/ChibiOS-Drivers/blob/master/inc/timcap_driver.h is an alternative driver if channels 3 & 4 really become an issue
! todo: only one channel per timer is allowed for capture simultaneously, that's an STM32 limitation
! todo: convert slow ADC to software scheduler and make TIM8 available
! todo: maybe convert fast ADC to software scheduler as well? less sure about that

#define brain_input_pin_e_enum "NONE",   "INVALID",  "INVALID", "PA1", "PA2", "PA3", "INVALID", "PA5", "PA6", "PA7", "PA8", "PA9", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "PA15",  "INVALID", "INVALID", "INVALID", "PB3", "PB4", "PB5", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "PC6", "PC7", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "PE5", "PE6", "INVALID", "INVALID", "PE9", "INVALID", "PE11", "INVALID", "INVALID", "INVALID", "INVALID",     "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID"
custom brain_input_pin_e 1 bits,    U08,   @OFFSET@, [0:7], @@brain_input_pin_e_enum@@

#define brain_pin_e_enum       "NONE",   "INVALID", "PA0",     "PA1", "PA2", "PA3", "PA4",     "PA5", "PA6", "PA7", "PA8", "PA9", "PA10",     "PA11",   "PA12",    "PA13",    "PA14",    "PA15",  "PB0",     "PB1",     "PB2",     "PB3", "PB4", "PB5", "PB6", "PB7", "PB8", "PB9", "PB10", "PB11", "PB12", "PB13", "PB14", "PB15", "PC0", "PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10", "PC11", "PC12", "PC13", "PC14", "PC15", "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", "PD6", "PD7", "PD8", "PD9", "PD10", "PD11", "PD12", "PD13", "PD14", "PD15", "PE0", "PE1", "PE2", "PE3", "PE4", "PE5", "PE6","PE7","PE8","PE9","PE10","PE11","PE12","PE13","PE14","PE15",       "PF0","PF1","PF2","PF3","PF4","PF5","PF6","PF7","PF8","PF9","PF10","PF11","PF12","PF13","PF14","PF15",          "PG0","PG1","PG2","PG3","PG4","PG5","PG6","PG7","PG8","PG9","PG10","PG11","PG12","PG13","PG14","PG15",             "PH0","PH1","PH2","PH3","PH4","PH5","PH6","PH7","PH8","PH9","PH10","PH11","PH12","PH13","PH14","PH15","INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID"
#define switch_input_pin_e_enum       "NONE",   "INVALID", "PA0",     "PA1", "PA2", "PA3", "PA4",     "PA5", "PA6", "PA7", "PA8", "PA9", "PA10",     "PA11",   "PA12",    "PA13",    "PA14",    "PA15",  "PB0",     "PB1",     "PB2",     "PB3", "PB4", "PB5", "PB6", "PB7", "PB8", "PB9", "PB10", "PB11", "PB12", "PB13", "PB14", "PB15", "PC0", "PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10", "PC11", "PC12", "PC13", "PC14", "PC15", "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", "PD6", "PD7", "PD8", "PD9", "PD10", "PD11", "PD12", "PD13", "PD14", "PD15", "PE0", "PE1", "PE2", "PE3", "PE4", "PE5", "PE6","PE7","PE8","PE9","PE10","PE11","PE12","PE13","PE14","PE15",       "PF0","PF1","PF2","PF3","PF4","PF5","PF6","PF7","PF8","PF9","PF10","PF11","PF12","PF13","PF14","PF15",          "PG0","PG1","PG2","PG3","PG4","PG5","PG6","PG7","PG8","PG9","PG10","PG11","PG12","PG13","PG14","PG15",             "PH0","PH1","PH2","PH3","PH4","PH5","PH6","PH7","PH8","PH9","PH10","PH11","PH12","PH13","PH14","PH15","INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID"

custom brain_pin_e 1 bits,    U08,   @OFFSET@, [0:7], @@brain_pin_e_enum@@
custom switch_input_pin_e 1 bits,    U08,   @OFFSET@, [0:7], @@switch_input_pin_e_enum@@

#define output_pin_e_enum       "NONE",   "INVALID", "PA0",     "PA1", "PA2", "PA3", "PA4",     "PA5", "PA6", "PA7", "PA8", "PA9", "PA10",     "PA11",   "PA12",    "PA13",    "PA14",    "PA15",  "PB0",     "PB1",     "PB2",     "PB3", "PB4", "PB5", "PB6", "PB7", "PB8", "PB9", "PB10", "PB11", "PB12", "PB13", "PB14", "PB15", "PC0", "PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10", "PC11", "PC12", "PC13", "PC14", "PC15", "PD0", "PD1", "PD2", "PD3", "PD4", "PD5", "PD6", "PD7", "PD8", "PD9", "PD10", "PD11", "PD12", "PD13", "PD14", "PD15", "PE0", "PE1", "PE2", "PE3", "PE4", "PE5", "PE6","PE7","PE8","PE9","PE10","PE11","PE12","PE13","PE14","PE15",       "PF0","PF1","PF2","PF3","PF4","PF5","PF6","PF7","PF8","PF9","PF10","PF11","PF12","PF13","PF14","PF15",          "PG0","PG1","PG2","PG3","PG4","PG5","PG6","PG7","PG8","PG9","PG10","PG11","PG12","PG13","PG14","PG15",             "PH0","PH1","PH2","PH3","PH4","PH5","PH6","PH7","PH8","PH9","PH10","PH11","PH12","PH13","PH14","PH15","TLE6240_1",   "TLE6240_2",   "TLE6240_3",   "TLE6240_4",   "TLE6240_5",   "TLE6240_6",   "TLE6240_7",   "TLE6240_8",    "TLE6240_9",    "TLE6240_10",    "TLE6240_11",    "TLE6240_12",    "TLE6240_13",    "TLE6240_14",   "TLE6240_15",   "TLE6240_16",   "MC33972_1",   "MC33972_2",   "MC33972_3",   "MC33972_4",   "MC33972_5",   "MC33972_6",   "MC33972_7",   "MC33972_8",    "MC33972_9",    "MC33972_10",    "MC33972_11",    "MC33972_12",    "MC33972_13",    "MC33972_14",   "MC33972_15",   "MC33972_16",   "MC33972_17",   "MC33972_18",   "MC33972_19",   "MC33972_20",   "MC33972_21",   "MC33972_22", "TLE8888_1",   "TLE8888_2",   "TLE8888_3",   "TLE8888_4",   "TLE8888_5",   "TLE8888_6",   "TLE8888_7",   "TLE8888_8",    "TLE8888_9",    "TLE8888_10",    "TLE8888_11",    "TLE8888_12",    "TLE8888_13",    "TLE8888_14",   "TLE8888_15",   "TLE8888_16",   "TLE8888_17",   "TLE8888_18",   "TLE8888_19",   "TLE8888_20",   "TLE8888_21",   "TLE8888_22",   "TLE8888_23", "TLE8888_24", "TLE8888_25", "TLE8888_26", "TLE8888_27", "TLE8888_28", "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",   "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID",    "INVALID"
custom output_pin_e 1 bits,    U08,   @OFFSET@, [0:7], @@output_pin_e_enum@@
 



#define pin_output_mode_e_enum "default", "default inverted", "open collector", "open collector inverted"
custom pin_output_mode_e 1 bits,    U08,   @OFFSET@, [0:7], @@pin_output_mode_e_enum@@

custom pin_input_mode_e 1 scalar, U08,	@OFFSET@,	"todo", 1, 0, 0, 20, 1	

struct spi_pins
	brain_pin_e mosiPin;
	brain_pin_e misoPin;
	brain_pin_e sckPin;
end_struct



custom air_pressure_sensor_type_e 4 bits, U32, @OFFSET@, [0:7]  "Custom Values", "MPX 4100", "MPX 4115", "MPX 4250", "MPX 4250A", "MPX 5700", "MPX H6300", "MPX 6400", "Gm 1 Bar", "Gm 2 Bar", "Gm 3 Bar", "Bosch 3 Bar TMAP", "Vag 250kPa", "Denso 079800", "DENSO 183", "Honda 3Bar", "Dodge Neon", "Toyota 89420 02010", "Subaru Denso", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID"
!
! lower 16 values are used on stm32 rusEfi, values above 16 are related to Kinetis work in progress
! 
#define adc_channel_e_enum "PA0", "PA1", "PA2", "PA3", "PA4", "PA5", "PA6", "PA7", "PB0", "PB1", "PC0", "PC1", "PC2", "PC3", "PC4", "PC5", "Disabled", "PB12", "PB13", "PC14", "PC15", "PC16", "PC17", "PD3", "PD4", "PE2", "PE6", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID"
custom adc_channel_e 1 bits, U08, @OFFSET@, [0:7]  @@adc_channel_e_enum@@

struct air_pressure_sensor_config_s
float lowValue;kPa value at low volts;"kpa",      1,     0,    -400, 800,     2
float highValue;kPa value at high volts;"kpa",      1,     0,    -400, 800,     2
air_pressure_sensor_type_e type;
adc_channel_e hwChannel;
uint8_t[3] align;

end_struct

struct MAP_sensor_config_s @brief MAP averaging configuration
float[MAP_ANGLE_SIZE] samplingAngleBins;;"",      1,     0,   0.0,    18000,   2
float[MAP_ANGLE_SIZE] samplingAngle;@brief MAP averaging sampling start angle, by RPM;"deg",      1,     0,   -720,    720,   2
float[MAP_WINDOW_SIZE] samplingWindowBins;;"",      1,     0,   0.0,    18000,   2
float[MAP_WINDOW_SIZE] samplingWindow;@brief MAP averaging angle duration, by RPM;"deg",      1,     0,   -720,    720,   2
air_pressure_sensor_config_s sensor
end_struct

struct_no_prefix thermistor_conf_s @brief Thermistor known values
float tempC_1;these values are in Celcius;"*C",       1,     0,    -40, 200,     1
float tempC_2;;"*C",       1,     0,    -40, 200,     1
float tempC_3;;"*C",       1,     0,    -40, 200,     1
float resistance_1;;"Ohm",      1,     0,    0, 200000,     1
float resistance_2;;"Ohm",      1,     0,    0, 200000,     1
float resistance_3;;"Ohm",      1,     0,    0, 200000,     1

	float bias_resistor;+Pull-up resistor value on your board;"Ohm",      1,     0,    0, 200000,     1
end_struct

struct oil_pressure_config_s @brief Oil pressure sensor interpolation
	adc_channel_e hwChannel;
	uint8_t[3] align;
	float v1;;         "volts",    1,    0.0,       0,    10.0,        2
	float value1;;     "kPa",    1,      0.0,       0,  1000.0,        2
	float v2;;         "volts",    1,    0.0,       0,    10.0,        2
	float value2;;     "kPa",    1,      0.0,       0,  1000.0,        2
end_struct

struct ThermistorConf @brief Thermistor curve parameters
	thermistor_conf_s config;
	adc_channel_e adcChannel;
end_struct

custom engine_type_e 4 bits, S32, @OFFSET@,   [0:7], "AUDI_AAN", "DODGE_NEON_1995", "FORD_ASPIRE_1996", "FORD_FIESTA", "NISSAN_PRIMERA", "HONDA_ACCORD", "FORD_INLINE_6_1995", "GY6_139QMB"
engine_type_e engineType;http://rusefi.com/wiki/index.php?title=Manual:Engine_Type\nset engine_type X

int engineSnifferRpmThreshold;Engine sniffer would be disabled above this rpm\nset engineSnifferRpmThreshold X;"RPM",      1,     0,    0,30000,      0

struct injector_s
	float flow;+This is your injector flow at the fuel pressure used in the vehicle. cc/min, cubic centimetre per minute\nBy the way, g/s = 0.125997881 * (lb/hr)\ng/s = 0.125997881 * (cc/min)/10.5\ng/s = 0.0119997981 * cc/min;"cm3/min",  1,     0,      0,  99999,   2

float[VBAT_INJECTOR_CURVE_SIZE] battLagCorrBins;set_flat_injector_lag LAG\nset_injector_lag VOLTAGE LAG;"volts",        1,     0,      0.0,    20.0,   2
float[VBAT_INJECTOR_CURVE_SIZE] battLagCorr;ms delay between injector open and close dead times;"ms",     1,     0,      0.0,    50.0,   2

end_struct

struct bi_quard_s
	float a0;;"v",  1,     0,      -1000,   1000,   9
	float a1;;"v",  1,     0,      -1000,   1000,   9
	float a2;;"v",  1,     0,      -1000,   1000,   9
	float b1;;"v",  1,     0,      -1000,   1000,   9
	float b2;;"v",  1,     0,      -1000,   1000,   9

end_struct

injector_s injector


bit directSelfStimulation;+Should trigger emulator push data right into trigger handling logic, eliminating the need for physical jumper wires?\nSee also triggerSimulatorPins\nPS: Funny name, right? :)
bit activateAuxPid1;
bit isVerboseAuxPid1;
bit activateAuxPid2;
bit isVerboseAuxPid2;
bit activateAuxPid3;
bit isVerboseAuxPid3;
bit activateAuxPid4;
bit isVerboseAuxPid4;
bit useBiQuadAnalogFiltering;
bit cj125isUaDivided;
bit cj125isLsu49;
bit etb_use_two_wires;
bit isDoubleSolenoidIdle;
bit showSdCardWarning;
bit cj125isUrDivided;looks like 3v range should be enough, divider not needed
bit useTLE8888_hall_mode;
bit useTLE8888_cranking_hack;
bit useInstantRpmForIdle;
bit absoluteFuelPressure;+If your fuel regulator does not have vacuum line
bit launchControlEnabled;
bit rollingLaunchEnabled;
bit antiLagEnabled;
bit useRunningMathForCranking,Fuel Map,Fixed;
bit issue_294_25;
bit issue_294_26;
bit issue_294_27;
bit issue_294_28;
bit issue_294_29;
bit issue_294_30;
bit issue_294_31;


int16_t tpsMin;Closed throttle. todo: extract these two fields into a structure\nSee also tps1_1AdcChannel\nset tps_min X;"ADC",      1,     0,    0, 1023,      0
int16_t tpsMax;Full throttle. tpsMax value as 10 bit ADC value. Not Voltage!\nSee also tps1_1AdcChannel\nset tps_max X;"ADC",      1,     0,    0, 1023,      0

int16_t tpsErrorDetectionTooLow;+TPS error detection, what TPS % value is unrealistically low;"%",       1,     0,    -40, 200,     0
int16_t tpsErrorDetectionTooHigh;+TPS error detection, what TPS % value is unrealistically high;"%",       1,     0,    -40, 200,     0

cranking_parameters_s cranking
float primingSquirtDurationMs;;"*C",       1,     0,    -40, 200,     1
	float ignitionDwellForCrankingMs;Used if useConstantDwellDuringCranking is TRUE;"ms",        1,     0,    0, 200,     1
float crankingChargeAngle;+While cranking (which causes battery voltage to drop) we can calculate dwell time in shaft\ndegrees, not in absolute time as in running mode.\nset cranking_charge_angle X;"deg",    1,      0,       0,  3000.0,      0


MAP_sensor_config_s map;@see hasMapSensor\n@see isMapAveragingEnabled


ThermistorConf clt;todo: merge with channel settings, use full-scale Thermistor here!
ThermistorConf iat;
	
	int launchRpm;A secondary Rev limit engaged by the driver to help launch the vehicle faster;"rpm",    1,      0,       0, 20000.0,        2
	float launchTimingRetard;;"deg",    1,      0,       -180, 180,        2
	int hip9011PrescalerAndSDO;+value '6' for 8MHz hw osc\nread hip9011 datasheet for details\ntodo split into two bit fields;"integer", 1, 0.0, 0.0, 32, 0
	float knockBandCustom;+We calculate knock band based of cylinderBore\n Use this to override - kHz knock band override;"kHz", 1, 0.0, 0.0, 10.0, 2


float[DWELL_CURVE_SIZE] sparkDwellRpmBins;On single-coil or wasted spark setups you have to lower dwell at high RPM;"RPM",     1,   0.0,      0.0,  18000,   2
	float[DWELL_CURVE_SIZE] sparkDwellValues;;"ms",	   1,   0.0,      0.0,  30.0,    2

struct_no_prefix specs_s
float displacement;Engine displacement, in litres\nsee also cylindersCount;"L",    1,      0,       0,  1000.0,        2

custom cylinders_count_t 4 bits,    U32,    @OFFSET@, [0:7], "INVALID", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, "INVALID", "INVALID", "INVALID"
cylinders_count_t cylindersCount;

! see firing_order.h
! FO_1 = 0
! FO_1_3_2_4 = 3
! FO_1_8_4_3_6_5_7_2 = 5
! FO_1_2_4_5_3 = 6

custom firing_order_e 4 bits,    U32,    @OFFSET@, [0:7], "One Cylinder", "1-3-4-2", "1-2-4-3", "1-3-2-4", "1-5-3-6-2-4", "1-8-4-3-6-5-7-2", "1-2-4-5-3", "1-4-2-5-3-6", "1-2", "1_2_3_4_5_6", "1-2-3", "1-8-7-2-6-5-4-3", "1-5-4-2-6-3-7-8", "1-6-3-2-5-4", "1-10-9-4-3-6-5-8-7_2", "1-7-5-11-3-9-6-12-2-8-4-10", "1-7-4-10-2-8-6-12-3-9-5-11", "1-4-3-2", "1-12-5-8-3-10-6-7-2-11-4-9", "1-2-7-8-4-5-6-3", "fo20", "fo21", "fo22", "INVALID"
firing_order_e firingOrder;
end_struct

    specs_s specs
	float cylinderBore;+Cylinder diameter, in mm.;"mm",    1,      0,       0, 20000.0,        2
int sensorSnifferRpmThreshold;+Disable sensor sniffer above this rpm;"RPM",      1,     0,    0,30000,      0
	int rpmHardLimit;set rpm_hard_limit X;"rpm",    1,      0,       0, 20000.0,        2


#define engine_load_mode_e_enum "MAF", "Alpha-N/TPS", "MAP", "SPEED DENSITY", "MAF Air Charge" 


custom engine_load_mode_e 4 bits, U32, @OFFSET@, [0:7], @@engine_load_mode_e_enum@@
engine_load_mode_e fuelAlgorithm;+This setting controls which fuel quantity control algorithm is used.\nSee also useTPSAdvanceTable\nset algorithm X


custom injection_mode_e 4 bits, U32, @OFFSET@, [0:7], "Simultaneous", "Sequential", "Batch", "Single Point"
injection_mode_e crankingInjectionMode;+This is the injection strategy during engine start.  See Fuel/Injection settings for more detail. It is suggested to use "Simultaneous".
injection_mode_e injectionMode;+This is where the fuel injection type is defined: "Simultaneous" means all injectors will fire together at once. "Sequential" fires the injectors on a per cylinder basis, which requires individually wired injectors. "Batched" will fire the injectors in groups.  If your injectors are individually wired you will also need to enable "Two wire batch emulation". \nset injection_mode X\nSee also twoWireBatchInjection
angle_t extraInjectionOffset;+this is about deciding when the injector starts it's squirt\nSee also injectionPhase map\ntodo: do we need even need this since we have the map anyway?;"deg",    1,      0.0,       -720,     720,        2
angle_t crankingTimingAngle;+Ignition advance angle used during engine cranking, 5-10 degrees will work as a base setting for most engines.\nset cranking_timing_angle X;     "deg",    1,      0.0,    -360,     360,        2

custom ignition_mode_e 4 bits,    U32,    @OFFSET@, [0:7], "One coil", "Individual Coils", "Wasted", "Two distributors"
ignition_mode_e ignitionMode;+"One Coil" is for use on distributed ignition system. "Individual Coils" is to be used when you have one coil per cylinder (COP or similar). "Wasted" means one coil is driving two spark plugs in two cylinders, with one of the sparks not doing anything since it's happening on the exhaust cycle\nset ignition_mode X

angle_t ignitionOffset;+this value could be used to offset the whole ignition timing table by a constant;"RPM",    1,      0,       0,  3000.0,      0

custom timing_mode_e 4 bits, U32, @OFFSET@ [0:0], "dynamic", "fixed"
timing_mode_e timingMode;+Dynamic uses the timing map to decide the ignition timing, Static timing fixes the timing to the value set below (only use for checking static timing).

angle_t fixedModeTiming;+This value is the ignition timing used when in 'fixed timing' mode, i.e. constant timing\nThis mode is useful when adjusting distributor location.;"RPM",    1,      0,       0,  3000.0,      0

angle_t globalTriggerAngleOffset;+Angle between Top Dead Center (TDC) and the first trigger event.\nKnowing this angle allows us to control timing and other angles in reference to TDC.\nset global_trigger_offset_angle X;"deg",    1,      0,       -720,  720, 0



float analogInputDividerCoefficient;+Coefficient of input voltage dividers on your PCB;"coef",    1,      0,    0.01,  10.0,   2
float vbattDividerCoeff;+This is the ratio of the resistors for the battery voltage, measure the voltage at the battery and then adjust this number until the gauge matches the reading.;"coef",    1,      0,    0.01,  99.0,        2

float fsio_visible fanOnTemperature;+Cooling fan turn-on temperature threshold, in Celsius;"*C",    1,      0,       0,  1000.0,        0
float fsio_visible fanOffTemperature;+Cooling fan turn-off temperature threshold, in Celsius;"*C",    1,      0,       0,  1000.0,        0


float vehicleSpeedCoef;+This coefficient translates vehicle speed input frequency (in Hz) into vehicle speed, km/h;"coef",    1,      0,    0.01,  2000.0,        2

custom can_nbc_e 4 bits, U32, @OFFSET@, [0:7], "BMW", "FIAT", "VAG" , "MAZDA RX8"
can_nbc_e canNbcType;set can_mode X

int canSleepPeriodMs;CANbus thread period, ms;"ms",    1,      0,       0,  1000.0,        2


custom operation_mode_e 4 bits,    U32,    @OFFSET@, [0:7], "INVALID", "4 stroke without cam sensor", "4 stroke with cam sensor", "2 stroke", "4 stroke with symmetrical crank (requires VVT input)", "INVALID", "INVALID", "INVALID"
operation_mode_e ambiguousOperationMode;+'Some triggers could be mounted differently. Most well-known triggers imply specific sensor setup. 4 stroke with symmetrical crank' is a pretty special case for example on Miata NB2\nSee engineCycle\nset operation_mode X

custom display_mode_e 4 bits,    U32,    @OFFSET@, [0:7], "none", "hd44780", "hd44780 over pcf8574", "INVALID"
display_mode_e displayMode;

custom log_format_e 4 bits,    U32,    @OFFSET@, [0:0], "native", "Mega Log Viewer"
log_format_e logFormat;
	int byFirmwareVersion;;"index",      1,      0,       0, 300,      0
	int HD44780width;;"index",      1,      0,       0, 300,      0
	int HD44780height;;"index",      1,      0,       0, 300,      0

	adc_channel_e tps1_1AdcChannel;First throttle body, first sensor. See also pedalPositionAdcChannel
adc_channel_e vbattAdcChannel;+This is the processor input pin that the battery voltage circuit is connected to, if you are unsure of what pin to use, check the schematic that corresponds to your PCB. 
adc_channel_e fuelLevelSensor;+This is the processor pin that your fuel level sensor in connected to. This is a non standard input so will need to be user defined. 
	adc_channel_e tps2_1AdcChannel;Second throttle body position sensor, single channel so far

	int overrideCrankingIgnition;
	int sensorChartFrequency;;"index",      1,      0,       0, 300,      0 ; size 4

struct trigger_config_s @brief Trigger wheel(s) configuration


custom bool32_t 4 bits,    U32,   @OFFSET@, [0:0], "false", "true"

#define trigger_type_e_enum "custom toothed wheel", "Ford Aspire", "Dodge Neon 1995", "Miata NA", "Miata NB", "GM_7X", "Cooper R50", "Mazda SOHC 4", "60/2", "36/1", "Honda 4+24+1", "Mitsubishi", "Honda 4+24", "Honda 1+4+24", "Dodge Neon 2003", "Mazda DOHC 1+4", "1+1", "1+60/2", "Single Tooth", "Dodge Ram 1+16", "60/2 VW", "Honda 1+24", "Dodge Stratus",  "36_2_2_2", "Nissan Primera", "2JZ", "Rover K", "GM LS 24", "Honda CBR 600", "2JZ_1_12", "Honda CBR 600 custom", "3/1 skipped" , "Dodge Neon 2003 crank", "Miata VVT", "trg34", "trg35", "Subaru 7+6", "Jeep 18-2-2-2", "WIP", "Dodge Neon 1995 crank only", "Jeep XJ 4 cyl", "FiatIAQ_P8", "Mazda Z5", "trg43", "Vag 60-2 VVT", "trg45", "INVALID"

custom trigger_type_e 4 bits,    U32,   @OFFSET@, [0:7], @@trigger_type_e_enum@@
	trigger_type_e type;set trigger_type X

	bit unusedTriggerBit0;
	bit unusedTriggerBit1;
	bit useOnlyFirstChannel;+This option could be used if your second trigger channel is broken

	int customTotalToothCount;;"number",    1,      0.0,       0,  500.0,        0
	int customSkippedToothCount;;"number",    1,      0.0,       0,  500.0,        0
end_struct

trigger_config_s trigger;

custom spi_device_e 1 bits,U32,   @OFFSET@, [0:7], "Off", "SPI1", "SPI2", "SPI3", "SPI4" 
	spi_device_e hip9011SpiDevice;
	adc_channel_e high_fuel_pressure_sensor_1;
	adc_channel_e high_fuel_pressure_sensor_2;
	adc_channel_e mafAdcChannel;See hasMafSensor
	
	
float globalFuelCorrection;set global_fuel_correction X;"coef",    1,      0.0,       0,  1000.0,        2

	float adcVcc;;         "volts",    1,    0.0,       0,    6.0,        3
	float maxKnockSubDeg;maximum total number of degrees to subtract from ignition advance\nwhen knocking
	brain_input_pin_e[CAM_INPUTS_COUNT iterate] camInputs;+Camshaft input could be used either just for engine phase detection if your trigger shape does not include cam sensor as 'primary' channel, or it could be used for Variable Valve timing on one of the camshafts.\nTODO #660
	
struct afr_sensor_s
	adc_channel_e hwChannel;
uint8_t[3] alignAf;
	float v1;;         "volts",    1,    0.0,       0,    10.0,        2
	float value1;;     "AFR",    1,      0.0,       0,  1000.0,        2
	float v2;;         "volts",    1,    0.0,       0,    10.0,        2
	float value2;;     "AFR",    1,      0.0,       0,  1000.0,        2
end_struct	
	
afr_sensor_s afr

adc_channel_e throttlePedalPositionAdcChannel;Electronic throttle pedal position input\nFirst channel\nSee also tps1_1AdcChannel
	brain_pin_e tle6240_cs;
	pin_output_mode_e tle6240_csPinMode;

switch_input_pin_e throttlePedalUpPin;+Throttle Pedal not pressed switch - used on some older vehicles like early Mazda Miata


air_pressure_sensor_config_s baroSensor;@see hasBaroSensor	

struct idle_hardware_s
	int solenoidFrequency;;"Hz",      1,      0,       0, 3000,      0

	brain_pin_e solenoidPin;
	brain_pin_e stepperDirectionPin;
	brain_pin_e stepperStepPin; 
	pin_output_mode_e solenoidPinMode;
end_struct

struct etb_io
	brain_pin_e directionPin1;
	brain_pin_e directionPin2;
	brain_pin_e controlPin1;
	pin_output_mode_e controlPinMode;
	
end_struct
	
	idle_hardware_s idle;

	float manIdlePosition;value between 0 and 100 used in Manual mode;"%", 1, 0, 0, 100, 0

float mapFrequency0Kpa;;"Hz",      1,      0,       0, 100000,      2
float mapFrequency100Kpa;;"Hz",      1,      0,       0, 100000,      2

! todo: rename to triggerSimulatorRpm
	int triggerSimulatorFrequency;+Same RPM is used for two ways of producing simulated RPM. See also triggerSimulatorPins (with wires)\nSee also directSelfStimulation (no wires, bypassing input hardware)\nrpm X;"Rpm",     1,      0,       0,30000,      0

	output_pin_e[INJECTION_PIN_COUNT iterate] injectionPins;
	output_pin_e[IGNITION_PIN_COUNT iterate] ignitionPins;

	pin_output_mode_e injectionPinMode;
	pin_output_mode_e ignitionPinMode;
	brain_pin_e HD44780_rs;
	brain_pin_e HD44780_e;

	brain_pin_e HD44780_db4;
	brain_pin_e HD44780_db5;
	brain_pin_e HD44780_db6;
	brain_pin_e HD44780_db7;

	brain_pin_e gps_rx_pin;
	brain_pin_e gps_tx_pin;
	output_pin_e fuelPumpPin;
	pin_output_mode_e fuelPumpPinMode;

	output_pin_e malfunctionIndicatorPin;+Check engine light, also malfunction indicator light. Always blinks once on boot.
	pin_output_mode_e malfunctionIndicatorPinMode;
	pin_output_mode_e fanPinMode;
	output_pin_e fanPin;

switch_input_pin_e clutchDownPin;some cars have a switch to indicate that clutch pedal is all the way down
	output_pin_e alternatorControlPin;
	pin_output_mode_e alternatorControlPinMode;
	pin_input_mode_e clutchDownPinMode;

	brain_pin_e[DIGIPOT_COUNT iterate] digitalPotentiometerChipSelect;
	pin_output_mode_e electronicThrottlePin1Mode;
	brain_pin_e wboHeaterPin;
	brain_pin_e cj125CsPin;
	spi_device_e max31855spiDevice;
	brain_pin_e debugTriggerSync;
	
spi_device_e digitalPotentiometerSpiDevice;Digital Potentiometer is used by stock ECU stimulation code
	brain_pin_e mc33972_cs;
	pin_output_mode_e mc33972_csPinMode;


custom adc_channel_mode_e 4 bits,    U32,   @OFFSET@, [0:7], "Off", "Slow", "Fast", "INVALID" 

	adc_channel_e auxFastSensor1_adcChannel;Useful in Research&Development phase
	adc_channel_e tps1_2AdcChannel;First throttle body, second sensor.
	adc_channel_e tps2_2AdcChannel;Second throttle body, second sensor.
	adc_channel_e throttlePedalPositionSecondAdcChannel;Electronic throttle pedal position input\nSecond channel\nSee also tps1_1AdcChannel

	

	float fuelLevelEmptyTankVoltage;;"V",      1,      0,       0,10,      2
	float fuelLevelFullTankVoltage;;"V",      1,      0,       0,10,      2

	ego_sensor_e afr_type;AFR, WBO, EGO - whatever you like to call it;
	float fuelClosedLoopAfrLowThreshold;;"ratio",        1,     0,  0,    100,  1

	brain_input_pin_e[TRIGGER_INPUT_PIN_COUNT iterate] triggerInputPins;
	pin_output_mode_e hip9011CsPinMode;
	output_pin_e tachOutputPin;+This implementation produces one pulse per engine cycle. See also dizzySparkOutputPin.
	pin_output_mode_e tachOutputPinMode;

	output_pin_e mainRelayPin;
	brain_pin_e sdCardCsPin;
	brain_pin_e canTxPin;
	brain_pin_e canRxPin;

pin_input_mode_e throttlePedalUpPinMode;
	brain_pin_e debugTimerCallback

	int idleThreadPeriodMs;
	int consoleLoopPeriodMs;
	int lcdThreadPeriodMs;

	int generalPeriodicThreadPeriodMs;

	uint32_t tunerStudioSerialSpeed;;"BPs",      1,      0,       0,1000000,      0

	can_device_mode_e canDeviceMode;
	
	brain_pin_e[TRIGGER_SIMULATOR_PIN_COUNT iterate] triggerSimulatorPins;Each rusEfi piece can provide synthetic trigger signal for external ECU. Sometimes these wires are routed back into trigger inputs of the same rusEfi board.\nSee also directSelfStimulation which is different.
	pin_output_mode_e[TRIGGER_SIMULATOR_PIN_COUNT iterate] triggerSimulatorPinModes;
	output_pin_e o2heaterPin;Narrow band o2 heater, not used for CJ125. See wboHeaterPin
	pin_output_mode_e o2heaterPinModeTodO;


bit is_enabled_spi_1
bit is_enabled_spi_2
	bit is_enabled_spi_3
	bit isSdCardEnabled
	bit isFastAdcEnabled
	bit isEngineControlEnabled
	bit isHip9011Enabled
	bit isVerboseAlternator
	bit useSerialPort
	bit useStepperIdle;+This setting should only be used if you have a stepper motor idle valve and a stepper motor driver installed. 
	
	bit enabledStep1Limiter;
	bit useTpicAdvancedMode;
	bit useLcdScreen;
	bit verboseTLE8888;
	bit unusedOldWarmupAfr;
	bit onOffAlternatorLogic; +This will cause the alternator to be operated in a basic on or off mode, this is the simplest alternator control.
	bit isCJ125Enabled
	bit vvtCamSensorUseRise;+Use rise or fall signal front
	bit measureMapOnlyInOneCylinder;+Useful for individual intakes
	bit stepperForceParkingEveryRestart
	bit isFasterEngineSpinUpEnabled;+Smarter cranking logic.\nSee also startOfCrankingPrimingPulse
	bit coastingFuelCutEnabled;+This setting disables fuel injection while the engine is in overrun, this is useful as a fuel saving measure and to prevent back firing.
	bit useIacTableForCoasting;+This setting allows the ECU to open the IAC during overrun conditions to help reduce engine breaking, this can be helpful for large engines in light weight cars.
	bit useNoiselessTriggerDecoder
	bit useIdleTimingPidControl
	bit useTPSBasedVeTable
	bit is_enabled_spi_4
	bit pauseEtbControl
	bit alignEngineSnifferAtTDC
	bit useETBforIdleControl;+This setting allows the ETB to act as the idle air control valve and move to regulate the airflow at idle.
	bit idleIncrementalPidCic
	bit enableAemXSeries

	brain_input_pin_e[LOGIC_ANALYZER_CHANNEL_COUNT iterate] logicAnalyzerPins;
	pin_output_mode_e mainRelayPinMode;
	brain_pin_e hip9011CsPin;
	brain_pin_e hip9011IntHoldPin;
pin_output_mode_e hip9011IntHoldPinMode;

	uint8_t[LOGIC_ANALYZER_CHANNEL_COUNT] logicAnalyzerMode;default or inverted input

	int unrealisticRpmThreashold;


	pin_output_mode_e[FSIO_COMMAND_COUNT iterate] gpioPinModes;
	output_pin_e[FSIO_COMMAND_COUNT iterate] fsioOutputPins;todo: more comments
	brain_pin_e[EGT_CHANNEL_COUNT iterate] max31855_cs;



custom uart_device_e 1 bits,U32,   @OFFSET@, [0:7], "Off", "UART1", "UART2", "UART3" 
	int16_t sdCardPeriodMs;+SD card logging period, in milliseconds;"ms",        1,     0,  0,    30000,  0
	brain_pin_e debugSetTimer
	brain_pin_e debugMapAveraging;
	brain_pin_e starterRelayPin;
	pin_output_mode_e starterRelayPinMode;
	brain_pin_e secondSolenoidPin;Some Subaru and some Mazda use double-solenoid idle air valve
	uint8_t[1] unuseduartPadding1;
	
	int mapMinBufferLength;;"count",        1,     0,  0,    24,  0
	int16_t idlePidDeactivationTpsThreshold;;"%",        1,     0,  0,    100.0,  0
	int16_t stepperParkingExtraSteps;;"%",        1,     0,  0,    3000.0,  0
	float miataNb2VVTRatioFrom;This magic property is specific to Mazda Miata NB2;"value",      1,      0,       0, 1000,      5
	float miataNb2VVTRatioTo;This magic property is specific to Mazda Miata NB2;"value",      1,      0,       0, 1000,      5

	brain_pin_e triggerErrorPin;+This pin is used for debugging - snap a logic analyzer on it and see if it's ever high
	pin_output_mode_e triggerErrorPinMode;
	output_pin_e acRelayPin;
	pin_output_mode_e acRelayPinMode;

custom pid_dt 4 scalar, U32,  @OFFSET@, "ms",      1,      0,       0, 3000,      0
custom fsio_pwm_freq_t 2 scalar,  U16,   @OFFSET@,         "Hz",      1,      0,       0, 3000,      0
	fsio_pwm_freq_t[FSIO_COMMAND_COUNT iterate] fsioFrequency;


custom fsio_setting_t 4 scalar,  F32,   @OFFSET@, 		"Val",	   1,	   0,       0, 18000,	  4
	fsio_setting_t[FSIO_COMMAND_COUNT iterate] fsio_setting;

! todo: migrate to spi_pins & combine with spi pin modes
	brain_pin_e spi1mosiPin;
	brain_pin_e spi1misoPin;
	brain_pin_e spi1sckPin;
	brain_pin_e spi2mosiPin;

	brain_pin_e spi2misoPin;
	brain_pin_e spi2sckPin;
	brain_pin_e spi3mosiPin;
	brain_pin_e spi3misoPin;

	brain_pin_e spi3sckPin;
	brain_pin_e cdmInputPin;+Saab Combustion Detection Module knock signal input pin\nalso known as Saab Ion Sensing Module
	brain_pin_e joystickCenterPin;
	brain_pin_e joystickAPin;

	brain_pin_e joystickBPin;
	brain_pin_e joystickCPin;
	brain_pin_e joystickDPin;
	uart_device_e consoleUartDevice;


#define sensor_chart_e_enum "none", "trigger", "MAP", "RPM ACCEL", "DETAILED RPM", "Fast Aux1", "INVALID", "INVALID"
custom sensor_chart_e 4 bits, S32, @OFFSET@, [0:7], @@sensor_chart_e_enum@@
sensor_chart_e sensorChartMode;+rusEfi console Sensor Sniffer mode


#define maf_sensor_type_e_enum "v0", "v1", "v2", "v3"
custom maf_sensor_type_e 4 bits, S32, @OFFSET@, [0:7], @@maf_sensor_type_e_enum@@

! todo: keep moving all these fields at the end of board_configuration_s below 'board_configuration_s bc'
! end of board_configuration_s

	maf_sensor_type_e mafSensorType;

	custom le_formula_t 200 string, ASCII, @OFFSET@, 200
	brain_pin_e[FSIO_COMMAND_COUNT iterate] fsioDigitalInputs;todo:not finished\nThese input pins allow us to pull toggle buttons state;

	brain_input_pin_e vehicleSpeedSensorInputPin;
	switch_input_pin_e clutchUpPin;Some vehicles have a switch to indicate that clutch pedal is all the way up
	brain_input_pin_e frequencyReportingMapInputPin;
	pin_input_mode_e clutchUpPinMode;
	float unused
	int unused1234
	etb_io[ETB_COUNT iterate] etbIo


    output_pin_e boostControlPin;
	pin_output_mode_e boostControlPinMode;
    output_pin_e vvtControlPin;
	pin_output_mode_e vvtControlPinMode;
    switch_input_pin_e antiLagActivatePin;
    switch_input_pin_e launchActivatePin;
float minVvtTemperature;;"*C",    1,      0,       0,  1000.0,        0

    pid_s boostPid;
	custom boostType_e 4 bits,   U32,   @OFFSET@, [0:0], "Open Loop",  "Closed Loop"
    boostType_e boostType;
uint8_t[4] unusedttt;
     custom vvtLoadAxis_e 4 bits,   U32,   @OFFSET@, [0:1], "TPS", "MAP", "CLT"
     vvtLoadAxis_e vvtLoadAxis;

	#define launchActivationMode_e_enum "Switch Input", "Clutch Input", "Always Active(Disabled By Speed)","INVALID"
    custom launchActivationMode_e  4 bits, S32, @OFFSET@, [0:7], @@launchActivationMode_e_enum@@
    launchActivationMode_e launchActivationMode;

    #define antiLagActivationMode_e_enum "Always Active", "Switch Input"
    custom antiLagActivationMode_e  4 bits, S32, @OFFSET@, [0:0], @@antiLagActivationMode_e_enum@@
    antiLagActivationMode_e antiLagActivationMode;

    int launchTpsTreshold;;"&",        1,     0,  0,    100,  0
    int launchSpeedTreshold;+Disabled above this speed;"Kph",        1,     0,  0,    300,  0
    int antiLagRpmTreshold;+Disabled below this rpm;"RPM",        1,     0,  0,    8000,  0
    int launchTimingRpmRange;+Range from Launch Rpm for Timing Retard to activate;"RPM",        1,     0,  0,    8000,  0
    int launchFuelAdded;+Extra Fuel Added;"%",        1,     0,  0,    100.0,  0
    int launchBoostDuty;+Duty Cycle for the Boost Solenoid;"%",        1,     0,  0,    100.0,  0
	int hardCutRpmRange;+RPM Range for Hard Cut;"rpm",    1,      0,       0, 3000,        1
    int antilagTimeout;+Time in Seconds;"Sec",    1,      0,       0, 50,        1
	int launchActivateDelay;+Time in Seconds;"Sec",    1,      0,       0, 50,        1
	
pid_s vvtPid;
int boostPwmFrequency;;"Hz",        1,     0,  0,    3000.0,  0
int vvtPwmFrequency;;"Hz",        1,     0,  0,    3000.0,  0
	float etbItermLimit;;"value",        1,     0, -500,    500,  1

	brain_pin_e cj125ModePin;
    pin_output_mode_e cj125ModePinMode;
	uint8_t[2] unusedPid;

custom gpPwm1Load_e 4 bits,   U32,   @OFFSET@, [0:1], "Map", "Tps", "Coolant"
     gpPwm1Load_e gpPwm1Load;

custom gpPwm2Load_e 4 bits,   U32,   @OFFSET@, [0:1], "Map", "Tps", "Coolant"
     gpPwm2Load_e gpPwm2Load;

custom gpPwm3Load_e 4 bits,   U32,   @OFFSET@, [0:1], "Map", "Tps", "Coolant"
     gpPwm3Load_e gpPwm3Load;

custom gpPwm4Load_e 4 bits,   U32,   @OFFSET@, [0:1], "Map", "Tps", "Coolant"
     gpPwm4Load_e gpPwm4Load;

int gpPwm1Frequency;;"Hz",        1,     0,  0,    3000.0,  0
int gpPwm2Frequency;;"Hz",        1,     0,  0,    3000.0,  0
int gpPwm3Frequency;;"Hz",        1,     0,  0,    3000.0,  0
int gpPwm4Frequency;;"Hz",        1,     0,  0,    3000.0,  0
output_pin_e gpPwm1Pin;
output_pin_e gpPwm2Pin;
output_pin_e gpPwm3Pin;
output_pin_e gpPwm4Pin;
pin_output_mode_e gpPwm1PinMode;
pin_output_mode_e gpPwm2PinMode;
pin_output_mode_e gpPwm3PinMode;
pin_output_mode_e gpPwm4PinMode;
float enableGpPwm1AtRpm;;"",    1,      0,       0,  8000.0,        0
float enableGpPwm2AtRpm;;"",    1,      0,       0,  8000.0,        0
float enableGpPwm3AtRpm;;"",    1,      0,       0,  8000.0,        0
float enableGpPwm4AtRpm;;"",    1,      0,       0,  8000.0,        0
float enableGpPwm1AtClt;;"",    1,      0,       0,  8000.0,        0
float enableGpPwm2AtClt;;"",    1,      0,       0,  8000.0,        0
float enableGpPwm3AtClt;;"",    1,      0,       0,  8000.0,        0
float enableGpPwm4AtClt;;"",    1,      0,       0,  8000.0,        0
float enableGpPwm1AtTps;;"",    1,      0,       0,  8000.0,        0
float enableGpPwm2AtTps;;"",    1,      0,       0,  8000.0,        0
float enableGpPwm3AtTps;;"",    1,      0,       0,  8000.0,        0
float enableGpPwm4AtTps;;"",    1,      0,       0,  8000.0,        0
float enableGpPwm1AtMap;;"",    1,      0,       0,  8000.0,        0
float enableGpPwm2AtMap;;"",    1,      0,       0,  8000.0,        0
float enableGpPwm3AtMap;;"",    1,      0,       0,  8000.0,        0
float enableGpPwm4AtMap;;"",    1,      0,       0,  8000.0,        0
	int maxVvtDeviation;;"Angle",        1,     0, -50,    50,  1

	  
  
 
 
 
    bit conditionGpPwm1Switch,Yes,No

    bit conditionGpPwm1Rpm,Yes,No
    bit gpPwm1BelowOrAboveRpm,Above,Below

    bit conditionGpPwm1Clt,Yes,No
	bit gpPwm1BelowOrAboveClt,Above,Below

    bit conditionGpPwm1Tps,Yes,No
	bit gpPwm1BelowOrAboveTps,Above,Below

	bit conditionGpPwm1Map,Yes,No
	bit gpPwm1BelowOrAboveMap,Above,Below


    bit conditionGpPwm2Switch,Yes,No

	bit conditionGpPwm2Rpm,Yes,No
	bit gpPwm2BelowOrAboveRpm,Above,Below
    
	bit conditionGpPwm2Clt,Yes,No
	bit gpPwm2BelowOrAboveClt,Above,Below
    
	bit conditionGpPwm2Tps,Yes,No
	bit gpPwm2BelowOrAboveTps,Above,Below
	
	bit conditionGpPwm2Map,Yes,No
	bit gpPwm2BelowOrAboveMap,Above,Below

switch_input_pin_e gpPwm1InputPin;
	switch_input_pin_e gpPwm2InputPin;
	switch_input_pin_e gpPwm3InputPin;
	switch_input_pin_e gpPwm4InputPin;


    bit conditionGpPwm3Switch,Yes,No

    bit conditionGpPwm3Rpm,Yes,No
    bit gpPwm3BelowOrAboveRpm,Above,Below

    bit conditionGpPwm3Clt,Yes,No
	bit gpPwm3BelowOrAboveClt,Above,Below

    bit conditionGpPwm3Tps,Yes,No
	bit gpPwm3BelowOrAboveTps,Above,Below

	bit conditionGpPwm3Map,Yes,No
	bit gpPwm3BelowOrAboveMap,Above,Below


    bit conditionGpPwm4Switch,Yes,No

	bit conditionGpPwm4Rpm,Yes,No
	bit gpPwm4BelowOrAboveRpm,Above,Below

    bit conditionGpPwm4Clt,Yes,No
    bit gpPwm4BelowOrAboveClt,Above,Below

    bit conditionGpPwm4Tps,Yes,No
	bit gpPwm4BelowOrAboveTps,Above,Below

    bit conditionGpPwm4Map,Yes,No
	bit gpPwm4BelowOrAboveMap,Above,Below

    bit vvtType,On/Off,Closed Loop

   

	int[58] unusedAtOldBoardConfigurationEnd;

	bit vvtDisplayInverted
	bit fuelClosedLoopCorrectionEnabled;+Enables lambda sensor closed loop feedback for fuelling.
	bit isVerboseIAC;+Print details into rusEfi console
	bit isVerboseETB;+Prints ETB details to rusEFI console
	bit useConstantDwellDuringCranking;+If set to true, will use the specified duration for cranking dwell. If set to false, will use the specified dwell angle.  Unless you have a really good reason to, leave this set to true to use duration mode.
	bit isEngineChartEnabled;+This options enables data for 'engine sniffer' tab in console, which comes at some CPU price 
	bit silentTriggerError;+Sometimes we have a performance issue while printing error
	bit useLinearCltSensor
	bit canReadEnabled
	bit canWriteEnabled
	bit useLinearIatSensor
	bit useFSIO16ForTimingAdjustment;+See fsioTimingAdjustment
	bit tachPulseDurationAsDutyCycle
	bit isAlternatorControlEnabled;+This enables smart alternator control and activates the extra alternator settings.
	bit invertPrimaryTriggerSignal;+This setting flips the signal from the primary engine speed sensor.
	bit invertSecondaryTriggerSignal;+This setting flips the signal from the secondary engine speed sensor.
	
bit cutFuelOnHardLimit
bit cutSparkOnHardLimit
bit launchFuelCutEnable
bit launchSparkCutEnable;+This is the Cut Mode normally used
bit hasFrequencyReportingMapSensor;
	bit useFSIO8ForServo1
	bit useFSIO9ForServo2
	bit useFSIO10ForServo3
	bit useFSIO11ForServo4
	bit useFSIO12ForServo5
bit useFSIO15ForIdleRpmAdjustment;
bit useFSIO5ForCriticalIssueEngineStop;Sometimes we just have to shut the engine down. Use carefully!
bit useFSIO4ForSeriousEngineWarning;Sometimes we have to miss injection on purpose to attract driver's attention
bit useFSIO12ForIdleOffset;
bit useFSIO13ForIdleMinValue;
bit useFSIO6ForRevLimiter;

	adc_channel_e hipOutputChannel;
	adc_channel_e acSwitchAdc;A/C button input handled as analogue input
	adc_channel_e vRefAdcChannel;
	uint8_t etbNeutralPosition;+Expected neutral position;"%",      1,      0,       0, 100,      0

custom idle_mode_e 4 bits,    U32,   @OFFSET@, [0:0], "Automatic", "Manual"
	idle_mode_e idleMode;See also idleRpmPid;

	bit isInjectionEnabled;+Enable fuel injection - This is default off for new projects as a safety feature, set to "true" to enable fuel injection and further injector settings.
	bit isIgnitionEnabled;+Enable ignition - This is default off for new projects as a safety feature, set to "true" to enable ignition and further ignition settings.
	bit isCylinderCleanupEnabled;+When enabled if TPS is held above 95% no fuel is injected while cranking to clear excess fuel from the cylinders. 
	bit secondTriggerChannelEnabled
	bit enableLaunchBoost
	bit isMapAveragingEnabled
	bit overrideCrankingIacSetting;+This setting overrides the normal multiplication values that have been set for the idle air control valve during cranking. If this setting is enabled the "IAC multiplier" table in the Cranking settings tab needs to be adjusted appropriately or potentially no IAC opening will occur.
	bit useSeparateAdvanceForIdle;+This activates a separate ignition timing table for idle conditions, this can help idle stability by using ignition retard and advance either side of the desired idle speed. Extra retard at low idle speeds will prevent stalling and extra advance at high idle speeds can help reduce engine power and slow the idle speed.
	bit isTunerStudioEnabled
	bit isWaveAnalyzerEnabled
	bit useSeparateVeForIdle;+This activates a separate fuel table for Idle, this allows fine tuning of the idle fuelling.
	bit verboseTriggerSynchDetails;+enable trigger_details
	bit isManualSpinningMode;Usually if we have no trigger events that means engine is stopped\nUnless we are troubleshooting and spinning the engine by hand - this case a longer\ndelay is needed
	bit twoWireBatchInjection;+This is needed if your coils are individually wired and you wish to use batch injection.\nenable two_wire_batch_injection
	bit useOnlyRisingEdgeForTrigger;+VR sensors are only precise on rising front\nenable trigger_only_front
	bit twoWireBatchIgnition;+This is needed if your coils are individually wired (COP) and you wish to use batch ignition (wasted spark).
bit useFixedBaroCorrFromMap
bit useSeparateAdvanceForCranking;+This activates a separate advance table for cranking conditions, this allows cranking advance to be RPM dependant.
bit useAdvanceCorrectionsForCranking;+This enables the various ignition corrections during cranking (IAT, CLT, FSIO and PID idle).
bit useTPSAdvanceTable;+This flag allows to use TPS for ignition lookup while in Speed Density Fuel Mode
bit etbCalibrationOnStart
bit useIacPidMultTable;+This flag allows to use a special 'PID Multiplier' table (0.0-1.0) to compensate for nonlinear nature of IAC-RPM controller
bit isBoostControlEnabled;
bit isVvtControlEnabled;
bit setEtbErrorRpm
bit isGpPwm1Enabled
bit isGpPwm2Enabled
bit isGpPwm3Enabled
bit isGpPwm4Enabled
bit launchDisableBySpeed
bit launchSmoothRetard;+Interpolates the Ignition Retard from 0 to 100% within the RPM Rangebit unused2
bit enableLaunchRetard

	uint32_t engineChartSize;;"count",      1,      0,       0, 300,      0


	int16_t idlePidRpmUpperLimit;+Relative to the target idle RPM;"",      1,      0,       0, 9000,      0
    int16_t primeInjFalloffTemperature;+This sets the temperature above which no priming pulse is used, The value at -40 is reduced until there is no more priming injection at this temperature.;"*C",    1,      0,       0,  1000.0,        0


	int ignMathCalculateAtIndex;+At what trigger index should some ignition-related math be executed? This is a performance trick to reduce load on synchronization trigger callback.;"index",      1,      0,       0, 7000,      0

	int16_t acCutoffLowRpm;
	int16_t acCutoffHighRpm;

	int16_t acIdleRpmBump;
	int16_t warningPeriod;set warningPeriod X;"seconds",      1,      0,       0, 60,      0


	float knockDetectionWindowStart;;"angle",      1,      0,       -1000, 1000,      2
	float knockDetectionWindowEnd;;"angle",      1,      0,       -1000, 1000,      2


float idleStepperReactionTime;;"ms",      1,      0,       1, 300,      0
	float knockVThreshold;;"V",      1,      0,       1, 5,      2

	pin_input_mode_e[FSIO_COMMAND_COUNT iterate] fsioInputModes;
	
	int idleStepperTotalSteps;;"count",      1,      0,       5, 3000,      0

float noAccelAfterHardLimitPeriodSecs;TODO: finish this #413;"sec",      1,      0,       0, 60,      0

int mapAveragingSchedulingAtIndex;+At what trigger index should some MAP-related math be executed? This is a performance trick to reduce load on synchronization trigger callback.;"index",      1,      0,       0, 7000,      0

float[BARO_CORR_SIZE] baroCorrPressureBins;;"kPa",      1,     0,   0.0,    200,   2
float[BARO_CORR_SIZE] baroCorrRpmBins;;"RPM",      1,     0,   0.0,    18000,   2

baro_corr_table_t baroCorrTable;
	
	#define pin_mode_e_enum "default", "INVALID", "INVALID", "INVALID", "opendrain", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "PULLUP", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "INVALID", "PULLDOWN"
custom pin_mode_e 1 bits,    U08,   @OFFSET@, [0:7], @@pin_mode_e_enum@@
	
	
	float[CRANKING_CURVE_SIZE] crankingTpsCoef;Cranking fuel correction coefficient based on TPS;"Ratio",      100,     0,      0.0,    700.0,   0
	float[CRANKING_CURVE_SIZE] crankingTpsBins;;"%",        1,     0,    0.0,    100.0,  2
	
	float tachPulseDuractionMs;;"ms",        1,     0,    0.0,    100.0,  2
	int tachPulseTriggerIndex;+Trigger cycle index at which we start tach pulse (performance consideration);"index",     1,     0,    0.0,    360.0,  0
	
	float wwaeTau;+Length of time the deposited wall fuel takes to dissipate after the start of acceleration. ;"Seconds",        1,     0,    0.0,    3.0,  2
	pid_s alternatorControl;
	pid_s etb;
	float fuelRailPressure;;     "kPa",    1,      0.0,       0,  1000.0,        2
	float alternator_derivativeFilterLoss;;    "x",    1,      0.0,       -1000000,  1000000,        4
	float alternator_antiwindupFreq;;    "x",    1,      0.0,       -1000000,  1000000,        4
int16_t tps2Min;Closed throttle#2. todo: extract these two fields into a structure\nSee also tps2_1AdcChannel\nset tps2_min X;"ADC",      1,     0,    0, 1023,      0
int16_t tps2Max;Full throttle#2. tpsMax value as 10 bit ADC value. Not Voltage!\nSee also tps1_1AdcChannel\nset tps2_max X;"ADC",      1,     0,    0, 1023,      0
	uint8_t[3] unusedFormerWarmupAfrPid;
	uint8_t tachPulsePerRev;;"Pulse",        1,     0,  1.0,    255.0,  0

! todo: mapErrorDetectionIdleTooLow? 30kPa is usually lowest on idle	
	float mapErrorDetectionTooLow;kPa value which is too low to be true;"kPa",        1,     0,    -100.0,    100.0,  2
	float mapErrorDetectionTooHigh;kPa value which is too high to be true;"kPa",        1,     0,    -100.0,    800.0,  2
	uint8_t[4] unusedSomething;
	pid_s idleRpmPid;See cltIdleRpmBins
	float wwaeBeta;+0 = No fuel settling on port walls 1 = All the fuel settling on port walls setting this to 0 disables the wall wetting enrichment. ;"Fraction",        1,     0,    0.0,    1.0,  2
	
	brain_pin_e communicationLedPin;blue LED on discovery by default	
	brain_pin_e runningLedPin;green LED on discovery by default
	brain_pin_e binarySerialTxPin;	
	brain_pin_e binarySerialRxPin;	
	
	brain_pin_e[AUX_DIGITAL_VALVE_COUNT iterate] auxValves
	brain_pin_e consoleSerialTxPin;	todo: finish pin migration from hard-coded to configurable?
	brain_pin_e consoleSerialRxPin;todo: finish pin migration from hard-coded to configurable?


	float[ENGINE_NOISE_CURVE_SIZE] knockNoise;Knock sensor output knock detection threshold depending on current RPM;"v",      1,     0,   0.0,    10,   2
	float[ENGINE_NOISE_CURVE_SIZE] knockNoiseRpmBins;;"RPM",      1,     0,   0.0,    18000,   2

	float throttlePedalUpVoltage;;"voltage",      1,     0,    -6,   6,      2
	float throttlePedalWOTVoltage;+Pedal in the floor;"voltage",      1,     0,    -6,   6,      2
	
	int16_t fsio_visible startUpFuelPumpDuration;+on ECU start turn fuel pump on to build fuel pressure;"seconds",        1,     0,  0,    6000,  0
	int16_t idlePidRpmDeadZone;If RPM is close enough let's leave IAC alone, and maybe engage timing PID correction;"",        1,     0,  0,    1000,  0
	


	float[CLT_CURVE_SIZE] cltIdleRpmBins;CLT-based target RPM for automatic idle controller;"C",        1,     0,   -100.0,    250.0,  2
	float[CLT_CURVE_SIZE] cltIdleRpm;See idleRpmPid;"",      1,     0,      0.0,    8000.0,   0
	
	float targetVBatt;+This is the target battery voltage the alternator PID control will attempt to maintain;"Volts",      1,      0,       0,30,      1
	float alternatorOffAboveTps;+Turns off alternator output above specified TPS, enabling this reduced parasitic drag on the engine at full load.;"%",  1,      0,       0, 200,      2
	float startOfCrankingPrimingPulse;+Prime pulse for cold engine, duration in ms\nLinear interpolation between -40F/-40C and fallout temperature\n\nSee also isFasterEngineSpinUpEnabled\nset cranking_priming_pulse X;"ms",        1,     0,    0, 200,     1
	int16_t afterCrankingIACtaperDuration;+This is the duration in cycles that the IAC will take to reach its normal idle position, it can be used to hold the idle higher for a few seconds after cranking to improve startup.;"cycles",        1,     0,  0,    5000,  0
	
	int16_t iacByTpsTaper;+Extra IAC, in percent between 0 and 100, tapered between zero and idle deactivation TPS value;"percent",        1,     0,  0,    500,  0

	brain_pin_e unusedErrorPin;
	brain_pin_e warningLedPin;
	brain_pin_e unused1234234;
	brain_pin_e LIS302DLCsPin;


	int tpsAccelLength;+This is the number of engine cycles that the TPS position change can occur over, a longer duration will make the enrichment more active but too long may affect steady state driving, a good default is 30-60 cycles. ;"cycles",        1,     0,    1, 200,     0
	float tpsAccelEnrichmentThreshold;+Maximum change delta of TPS percentage over the 'length'. Actual TPS change has to be above this value in order for TPS/TPS acceleration to kick in.;"roc",        1,     0,    0, 200,     3
	float vvtOffset;+Angle between cam sensor and VVT zero position\nset vvt_offset X;"",      1,      0,       -720, 1000,      1
	
	int engineLoadAccelLength;;"cycles",        1,     0,    1, 200,     0
	
	float engineLoadDecelEnleanmentThreshold;;"roc",        1,     0,    0, 200,     3
	float engineLoadDecelEnleanmentMultiplier;;"coeff",        1,     0,    0, 200,     3
	float engineLoadAccelEnrichmentThreshold;;"roc",        1,     0,    0, 200,     3
	float engineLoadAccelEnrichmentMultiplier;;"coeff",        1,     0,    0, 200,     3



	uint32_t uartConsoleSerialSpeed;;"BPs",      1,      0,       0,1000000,      0
	float tpsDecelEnleanmentThreshold;;"roc",        1,     0,    0, 200,     3
	float tpsDecelEnleanmentMultiplier;;"coeff",        1,     0,    0, 200,     3
	float slowAdcAlpha;+ExpAverage alpha coefficient;"coeff",        1,     0,    0, 200,     3
	debug_mode_e debugMode;+See http://rusefi.com/s/debugmode\n\nset debug_mode X

	uint32_t[9] unused_former_warmup_target_afr;

	float boostCutPressure;kPa value at which we need to cut fuel and spark, 0 if not enabled;"kPa",        1,     0,    0, 500,     0

float[MAP_ACCEL_TAPER] mapAccelTaperBins;;"counter",      1,     0,   0.0,    300,   0
float[MAP_ACCEL_TAPER] mapAccelTaperMult;;"mult",      1,     0,   0.0,    300,   2

	adc_channel_e[FSIO_ANALOG_INPUT_COUNT iterate] fsioAdc;todo: rename to fsioAnalogInputs
	float fixedTiming;Fixed timing, useful for TDC testing;"deg",      1,     0,   -720,    720,   2
	float mapLowValueVoltage;MAP voltage for low point;"v",      1,     0,   0.0,    10,   2 
	float mapHighValueVoltage;MAP voltage for low point;"v",      1,     0,   0.0,    10,   2 
	float egoValueShift;EGO value correction;"value",      1,     0,   -10.0,    10,   2 

	output_pin_e[AUX_PID_COUNT iterate] auxPidPins;

	spi_device_e cj125SpiDevice;
	pin_output_mode_e cj125CsPinMode;
	brain_pin_e dizzySparkOutputPin;+This implementation makes a pulse every time one of the coils is charged, using coil dwell for pulse width. See also tachOutputPin
	pin_output_mode_e dizzySparkOutputPinMode;

	int crankingIACposition;+This is the IAC position during cranking, some engines start better if given more air during cranking to improve cylinder filling.;"",      1,     0,   -100.0,    100,
	float tChargeMinRpmMinTps;;"mult",        1,     0,  0,    3,  4
	float tChargeMinRpmMaxTps;;"mult",        1,     0,  0,    3,  4
	float tChargeMaxRpmMinTps;;"mult",        1,     0,  0,    3,  4
	float tChargeMaxRpmMaxTps;;"mult",        1,     0,  0,    3,  4   

	fsio_pwm_freq_t[AUX_PID_COUNT iterate] auxPidFrequency;
	int alternatorPwmFrequency;;"Hz",        1,     0,  0,    3000.0,  0
	mass_storage_e storageMode;

	float[NARROW_BAND_WIDE_BAND_CONVERSION_SIZE] narrowToWideOxygenBins;Narrow Band WBO Approximation;"V",        1,     0,   -10.0,    10.0,  3
	float[NARROW_BAND_WIDE_BAND_CONVERSION_SIZE] narrowToWideOxygen;;"ratio",      1,     0,      -40.0,    40.0,   2
	vvt_mode_e vvtMode;set vvt_mode X
	bi_quard_s biQuad;
	float[CLT_TIMING_CURVE_SIZE] cltTimingBins;CLT-based timing correction;"C",        1,     0,   -100.0,    250.0,  1
	float[CLT_TIMING_CURVE_SIZE] cltTimingExtra;;"degree",      1,     0,      -400.0,    400.0,   0
	int nbVvtIndex;;"index",        1,     0,  0,    4.0,  0
	float autoTuneCltThreshold;
	float autoTuneTpsRocThreshold;
	float autoTuneTpsQuietPeriod;
	float postCrankingTargetClt;;"C",        1,     0,  0,    100,  0
	float postCrankingFactor;Fuel multiplier taper, see also postCrankingDurationSec;"mult",        1,     0,  0,    100,  4
	float postCrankingDurationSec;See also postCrankingFactor;"seconds",        1,     0,  0,    100,  2
	ThermistorConf auxTempSensor1;todo: finish implementation #332
	ThermistorConf auxTempSensor2;todo: finish implementation #332
	int16_t fuelClosedLoopCltThreshold;;"C",        1,     0,  0,    100,  0
	int16_t fuelClosedLoopTpsThreshold;;"%",        1,     0,  0,    100,  0
	int16_t fuelClosedLoopRpmThreshold;;"rpm",        1,     0,  0,    5000,  0
	int16_t etbFreq;;"Hz",      1,     0,    0, 30000,      0
	pid_s fuelClosedLoopPid;
	float fuelClosedLoopAfrHighThreshold;;"ratio",        1,     0,  0,    100,  1
	
	custom cfg_float_t_1f 4 scalar,  F32,   @OFFSET@, 		"Val",	   1,	   0,       -20000000, 20000000,	  1
	cfg_float_t_1f[IGNITION_PIN_COUNT iterate] timing_offset_cylinder;per-cylinder timing correction

	
	float idlePidActivationTime;;"seconds",        1,     0,  0,    60,  1

	spi_device_e sdCardSpiDevice;
	uint8_t[3] unusedSpiPadding4;

	pin_mode_e spi1SckMode;
	pin_mode_e spi1MosiMode;
	pin_mode_e spi1MisoMode;
	pin_mode_e spi2SckMode;
	
	pin_mode_e spi2MosiMode;
	pin_mode_e spi2MisoMode;
    pin_mode_e spi3SckMode;
	pin_mode_e spi3MosiMode;
	
	pin_mode_e spi3MisoMode;
	pin_output_mode_e stepperEnablePinMode;
	brain_pin_e mc33816_rstb;ResetB
	brain_pin_e mc33816_driven

	switch_input_pin_e brakePedalPin;Brake pedal switch
	adc_channel_e cj125ua;lambda input
	adc_channel_e cj125ur;heater input
	pin_input_mode_e brakePedalPinMode;


	pid_s[AUX_PID_COUNT iterate] auxPid;

	oil_pressure_config_s oilPressure;

	spi_device_e accelerometerSpiDevice;
	uint8_t[3] unusedSpiPadding5;
	float[FSIO_CURVE_16] fsioCurve1Bins;;"x",        1,     0,   -999,    1000.0,  3
	float[FSIO_CURVE_16] fsioCurve1;;"y",      1,     0,      -999,    1000.0,   3
	float[FSIO_CURVE_16] fsioCurve2Bins;;"x",        1,     0,   -999,    1000.0,  3
	float[FSIO_CURVE_16] fsioCurve2;;"y",      1,     0,      -999,    1000.0,   3
	float[FSIO_CURVE_8] fsioCurve3Bins;;"x",        1,     0,   -999,    1000.0,  3
	float[FSIO_CURVE_8] fsioCurve3;;"y",      1,     0,      -999,    1000.0,   3
	float[FSIO_CURVE_8] fsioCurve4Bins;;"x",        1,     0,   -999,    1000.0,  3
	float[FSIO_CURVE_8] fsioCurve4;;"y",      1,     0,      -999,    1000.0,   3

	uint8_t unusedFlexFuelSensor;
	brain_pin_e test557pin
	pin_output_mode_e stepperDirectionPinMode;
	adc_channel_e externalKnockSenseAdc;
	brain_pin_e stepperEnablePin;
	brain_pin_e tle8888_cs;
	pin_output_mode_e tle8888_csPinMode;
	brain_pin_e mc33816_cs;

float[CRANKING_ADVANCE_CURVE_SIZE] crankingAdvanceBins;+Optional timing advance table for Cranking (see useSeparateAdvanceForCranking);"RPM",      1,     0,   0.0,    18000,   2
float[CRANKING_ADVANCE_CURVE_SIZE] crankingAdvance    ;+Optional timing advance table for Cranking (see useSeparateAdvanceForCranking);"deg",      1,     0,     -20, 90,    2

	brain_pin_e[SERVO_COUNT iterate] servoOutputPins;todo: more comments

	int16_t coastingFuelCutRpmHigh;+This sets the RPM limit above which the fuel cut is deactivated, activating this maintains fuel flow at high RPM to help cool pistons;"rpm",        1,     0,  0,    5000,  0
	int16_t coastingFuelCutRpmLow;+This sets the RPM limit below which the fuel cut is deactivated, this prevents jerking or issues transitioning to idle;"rpm",        1,     0,  0,    5000,  0
	int16_t coastingFuelCutTps;+percent between 0 and 100 below which the fuel cut is deactivated, this helps low speed drivability.;"%",        1,     0,  0,    100,  1
	int16_t coastingFuelCutClt;+Fuel cutoff is deactivated below this coolant threshold.;"C",        1,     0,  -100,    100,  0
	
	int16_t pidExtraForLowRpm;+Increases PID reaction for RPM<target by adding extra percent to PID-error;"%",        1,     0,  0,    100,  0
	int16_t coastingFuelCutMap;+MAP value above which fuel injection is re-enabled.;"kPa", 1, 0, 0, 250, 0
	
float[CLT_CURVE_SIZE] iacCoastingBins;CLT-based idle position for coasting (used in Auto-PID Idle mode);"C",        1,     0,   -100.0,    250.0,  2
float[CLT_CURVE_SIZE] iacCoasting;    CLT-based idle position for coasting (used in Auto-PID Idle mode);"%",      1,     0,      0.0,    100.0,   2

ignition_tps_table_t ignitionTpsTable;
float[IGN_TPS_COUNT] ignitionTpsBins;;"TPS",   1,   0.0,        0,  100.0,   2

float tChargeAirCoefMin;;"Min tCharge Coeff.",        1,     0,  0.0,    1.0,  4
float tChargeAirCoefMax;;"Max tCharge Coeff.",        1,     0,  0.0,    1.0,  4
float tChargeAirFlowMax;;"Max Air Flow, kg/h",        1,     0,  0.0,    1000.0,  1
float tChargeAirIncrLimit;;"tChange Increment Limit, deg/sec",        1,     0,  0.0,    100.0,  1
float tChargeAirDecrLimit;;"tChange Decrement Limit, deg/sec",        1,     0,  0.0,    100.0,  1

#define tChargeMode_e_enum "RPM+TPS (Default)", "Air Mass Interpolation"
custom tChargeMode_e 4 bits,    U32,   @OFFSET@, [0:0], @@tChargeMode_e_enum@@
tChargeMode_e tChargeMode;
	
	
		float[ETB_BIAS_CURVE_LENGTH] etbBiasBins;target TPS value, 0 to 100%\nTODO: use int8 data date once we template interpolation method;"target TPS position",   1,   0.0,        0,  100.0,   1
		float[ETB_BIAS_CURVE_LENGTH] etbBiasValues;PWM bias, 0 to 100%;"ETB duty cycle bias",   1,   0.0,        -100,  100.0,   2
	
	float hip9011Gain;
	int16_t etb_iTermMin;iTerm min value;"",        1,     0,  -30000,    30000.0,  0
	int16_t etb_iTermMax;iTerm max value;"",        1,     0,  -30000,    30000.0,  0
	float etbDeadband;;"",        1,     0,  0,    100.0,  2
	uint8_t[4] unused1059;

	pid_s idleTimingPid;See useIdleTimingPidControl
	int16_t idleTimingPidWorkZone;+When the current RPM is closer than this value to the target, closed-loop idle timing control is enabled.;"RPM",        1,     0,  0,    1000,  0
	int16_t idleTimingPidDeadZone;+If the RPM closer to target than this value, disable timing correction to prevent oscillation;"RPM",        1,     0,  0,    1000,  0
	int16_t idlePidFalloffDeltaRpm;+Taper out idle timing control over this range as the engine leaves idle conditions;"RPM",        1,     0,  0,    1000,  0

	int16_t tpsAccelFractionPeriod;+A delay in cycles between fuel-enrich. portions;"cycles",        1,     0,  0,    500,  0
	float tpsAccelFractionDivisor;+A fraction divisor: 1 or less = entire portion at once, or split into diminishing fractions;"coef",        1,     0,  0,    100,  2

	spi_device_e tle8888spiDevice;
	spi_device_e mc33816spiDevice;
	int16_t idlerpmpid_iTermMin;iTerm min value;"",        1,     0,  -30000,    30000.0,  0

	spi_device_e tle6240spiDevice;
	uint8_t[1] unusedSpiPadding7;
	int16_t idlerpmpid_iTermMax;iTerm max value;"",        1,     0,  -30000,    30000.0,  0

	spi_device_e mc33972spiDevice;
	uint8_t[3] unusedSpiPadding8;


	float etbIdleThrottleRange; ETB idle authority; "%", 1, 0, 0, 15, 0

uint8_t[4] unusuedvref;
uint8_t[4] unusuedsw;
	int[3] alFIn;

	uint8_t triggerCompCenterVolt;+Trigger comparator center point voltage;"V",        @@VOLTAGE_1_BYTE_PACKING_DIV@@,     0,      0.0,   5.1,   2
	uint8_t triggerCompHystMin;+Trigger comparator hysteresis voltage (Min);"V",        @@VOLTAGE_1_BYTE_PACKING_DIV@@,     0,      0.0,   5.1,   2
	uint8_t triggerCompHystMax;+Trigger comparator hysteresis voltage (Max);"V",        @@VOLTAGE_1_BYTE_PACKING_DIV@@,     0,      0.0,   5.1,   2
	uint8_t triggerCompSensorSatRpm;+VR-sensor saturation RPM;"RPM",        @@RPM_1_BYTE_PACKING_MULT@@,     0,      0.0,   12000.0,   0

	pid_s idleRpmPid2

	iac_pid_mult_t iacPidMultTable;
	uint8_t[IAC_PID_MULT_SIZE] iacPidMultLoadBins;;"Load",   1,   0.0,        0,  500.0,   2
	uint8_t[IAC_PID_MULT_SIZE] iacPidMultRpmBins;;"RPM",        @@RPM_1_BYTE_PACKING_MULT@@,     0,      0.0,   12000.0,   0	

int[319] mainUnusedEnd;

! end of engine_configuration_s
end_struct

engine_configuration_s engineConfiguration;
	


float[AFTERSTART_HOLD_CURVE_SIZE] afterstartHoldTimeBins;;"C",        1,     0,   -100.0,    250.0,  0
float[AFTERSTART_HOLD_CURVE_SIZE] afterstartHoldTime;;"Seconds",      1,     0,      0,    100,   1

float[AFTERSTART_DECAY_CURVE_SIZE] afterstartDecayTimeBins;;"C",        1,     0,   -100.0,    250.0,  0
float[AFTERSTART_DECAY_CURVE_SIZE] afterstartDecayTime;;"Seconds",      1,     0,      0,    100,   1

float[AFTERSTART_ENRICH_CURVE_SIZE] afterstartEnrichBins;;"C",        1,     0,   -100.0,    250.0,  0
float[AFTERSTART_ENRICH_CURVE_SIZE] afterstartEnrich;;"%",            100,     -1,      0,    600,   1


gp_pwm_table_t gpPwmTable1;

uint8_t[GP_PWM_LOAD_COUNT] gpPwm1LoadBins;;{ bitStringValue(algorithmUnits ,  gpPwm1Load) },              1,           0,     0,     600.0,      1
uint8_t[GP_PWM_RPM_COUNT] gpPwm1RpmBins;;"RPM",   @@RPM_1_BYTE_PACKING_MULT@@,     0,      0.0,   12000.0,   0 

gp_pwm_table_t gpPwmTable2;
uint8_t[GP_PWM_LOAD_COUNT] gpPwm2LoadBins;;{ bitStringValue(algorithmUnits ,  gpPwm2Load) }, 1,   0,        0,  600.0,   1
uint8_t[GP_PWM_RPM_COUNT] gpPwm2RpmBins;;"RPM",   @@RPM_1_BYTE_PACKING_MULT@@,     0,      0.0,   12000.0,   0 


gp_pwm_table_t gpPwmTable3;
uint8_t[GP_PWM_LOAD_COUNT] gpPwm3LoadBins;;{ bitStringValue(algorithmUnits ,  gpPwm3Load) }, 1,   0,        0,  600.0,   1
uint8_t[GP_PWM_RPM_COUNT] gpPwm3RpmBins;;"RPM",   @@RPM_1_BYTE_PACKING_MULT@@,     0,      0.0,   12000.0,   0 

gp_pwm_table_t gpPwmTable4;
uint8_t[GP_PWM_LOAD_COUNT] gpPwm4LoadBins;;{ bitStringValue(algorithmUnits ,  gpPwm4Load) }, 1,   0,        0,  600.0,   1
uint8_t[GP_PWM_RPM_COUNT] gpPwm4RpmBins;;"RPM",   @@RPM_1_BYTE_PACKING_MULT@@,     0,      0.0,   12000.0,   0 

fsio_table_8x8_f32t vvtTable1;

!vvt_table_f32t vvtTable;
float[VVT_LOAD_COUNT] vvtLoadBins;;"Load",  1,   0,        0,  500.0,   2
float[VVT_RPM_COUNT] vvtRpmBins;;"RPM",	   @@RPM_1_BYTE_PACKING_MULT@@,     0,      0.0,   12000.0,   0 

boost_table_t boostTableOpenLoop;
uint8_t[BOOST_LOAD_COUNT] boostMapBins;;"",  @@LOAD_1_BYTE_PACKING_MULT@@,   0,        0,  600.0,   1
uint8_t[BOOST_RPM_COUNT] boostRpmBins;;"RPM",   @@RPM_1_BYTE_PACKING_MULT@@,     0,      0.0,   12000.0,   0 

boost_table_t boostTableClosedLoop;
uint8_t[BOOST_LOAD_COUNT] boostTpsBins;;"%",   @@TPS_1_BYTE_PACKING_MULT@@,   0.0,        0,  100.0,   2

pedal_to_tps_t pedalToTpsTable;
uint8_t[PEDAL_TO_TPS_SIZE] pedalToTpsPedalBins;;"%",           1,     0,      0.0,   120.0,   0
! it's not serious to use one byte for RPM but let me try that just to try it
uint8_t[PEDAL_TO_TPS_SIZE] pedalToTpsRpmBins;;"RPM",        @@RPM_1_BYTE_PACKING_MULT@@,     0,      0.0,   12000.0,   0

float[CLT_CRANKING_CURVE_SIZE] cltCrankingCorrBins;CLT-based cranking position multiplier for simple manual idle controller;"C",        1,     0,   -100.0,    250.0,  2
float[CLT_CRANKING_CURVE_SIZE] cltCrankingCorr    ;CLT-based cranking position multiplier for simple manual idle controller;"%",      100,     0,      0.0,    500.0,   0

float[IDLE_ADVANCE_CURVE_SIZE] idleAdvanceBins;Optional timing advance table for Idle (see useSeparateAdvanceForIdle);"RPM",      1,     0,   0.0,    18000,   2
float[IDLE_ADVANCE_CURVE_SIZE] idleAdvance    ;Optional timing advance table for Idle (see useSeparateAdvanceForIdle);"deg",      1,     0,     -20, 90,    2
float[IDLE_VE_CURVE_SIZE] idleVeBins;Optional VE table for Idle (see useSeparateVEForIdle);"RPM",      1,     0,   0.0,    18000,   2
float[IDLE_VE_CURVE_SIZE] idleVe;    Optional VE table for Idle (see useSeparateVEForIdle);,"%", 1, 0, 0, 999.0, 2

le_formula_t[FSIO_COMMAND_COUNT iterate] fsioFormulas;
	le_formula_t timingMultiplier;
	le_formula_t timingAdditive;

float[CLT_CURVE_SIZE] cltFuelCorrBins;;"C",        1,     0,   -100.0,    250.0,  0
float[CLT_CURVE_SIZE] cltFuelCorr;;"% Trim",      100,     -1,      -100,    500,   1

float[IAT_CURVE_SIZE] iatFuelCorrBins;;"C",        1,     0,   -100.0,    250.0,   0
float[IAT_CURVE_SIZE] iatFuelCorr;;"% Trim",      100,     -1,      -100,    400,   1

	float[CRANKING_CURVE_SIZE] crankingFuelCoef;;"%",      100,     -1,      -100,    400,   1
	float[CRANKING_CURVE_SIZE] crankingFuelBins;;"C",        1,     0,    -80.0,    170.0,  0

	float[CRANKING_CURVE_SIZE] crankingCycleCoef;;"%",      100,     -1,      -100,    400,   1
	float[CRANKING_CURVE_SIZE] crankingCycleBins;;"counter",        1,     0,    -80.0,    170.0,  0

float[CLT_CURVE_SIZE] cltIdleCorrBins;CLT-based idle position multiplier for simple manual idle controller;"C",        1,     0,   -100.0,    250.0,  1
float[CLT_CURVE_SIZE] cltIdleCorr;    CLT-based idle position multiplier for simple manual idle controller;"percent",      100,     0,      0.0,   400,   0

float[MAF_DECODING_COUNT] mafDecoding;kg/hour value.\nBy the way 2.081989116 kg/h = 1 ft3/m;"kg/hour", 1, 0, -500.0, 4000.0, 2
float[MAF_DECODING_COUNT] mafDecodingBins;; "V", 1, 0, -5.0, 150.0, 2

angle_table_t ignitionIatCorrTable;
float[IGN_LOAD_COUNT] ignitionIatCorrLoadBins;;"Temperature",   1,   0.0,        0,  500.0,   1
float[IGN_RPM_COUNT] ignitionIatCorrRpmBins;;"RPM",	   1,   0.0,        0,  18000.0, 1

angle_table_t injectionPhase;
float[FUEL_LOAD_COUNT] injPhaseLoadBins;;"Load",   1,   0.0,        0,  500.0,   2
float[FUEL_RPM_COUNT] injPhaseRpmBins;;"RPM",	   1,   0.0,        0,  18000.0, 2

fuel_table_t fuelTable;
float[FUEL_LOAD_COUNT] fuelLoadBins;;"V",	   1,      0,      0.0,  500.0,   2
float[FUEL_RPM_COUNT] fuelRpmBins;RPM is float and not integer in order to use unified methods for interpolation;"RPM",	   1,      0,      0.0,  25500.0,   2

ignition_table_t ignitionTable;
float[IGN_LOAD_COUNT] ignitionLoadBins;;"Load",   1,   0.0,        0,  500.0,   2
float[IGN_RPM_COUNT] ignitionRpmBins;;"RPM",	   1,   0.0,        0,  18000.0, 2

ve_table_t fuelTable;
float[FUEL_LOAD_COUNT] fuelLoadBins;;"kPa",	1,   0.0,        0,  400.0,   2
float[FUEL_RPM_COUNT] fuelRpmBins;;"RPM",	   1,   0.0,        0,  18000.0, 2

afr_table_t afrTable;		
float[FUEL_LOAD_COUNT] afrLoadBins;;"",	1,   0.0,        0,  500.0,   2
float[FUEL_RPM_COUNT] afrRpmBins;;"RPM",	   1,   0.0,        0,  18000.0, 2

! ve_table_t ve2Table;
! float[FUEL_LOAD_COUNT] ve2LoadBins;;"kPa",	1,   0.0,        0,  500.0,   2
! float[FUEL_RPM_COUNT] ve2RpmBins;;"RPM",	   1,   0.0,        0,  18000.0, 2

tps_tps_table_t tpsTpsAccelTable;
float[TPS_TPS_ACCEL_TABLE] tpsTpsAccelFromRpmBins;;"from",	   1,      0,      0.0,  30000.0,   2
float[TPS_TPS_ACCEL_TABLE] tpsTpsAccelToRpmBins;RPM is float and not integer in order to use unified methods for interpolation;"to",	   1,      0,      0.0,  25500.0,   2

fsio_table_8x8_f32t fsioTable1;
float[FSIO_TABLE_8] fsioTable1LoadBins;;"L",	   1,      0,      0.0,  30000.0,   2
float[FSIO_TABLE_8] fsioTable1RpmBins;RPM is float and not integer in order to use unified methods for interpolation;"RPM",	   1,      0,      0.0,  25500.0,   2

fsio_table_8x8_u8t fsioTable2;
float[FSIO_TABLE_8] fsioTable2LoadBins;;"L",	   1,      0,      0.0,  255,   0
float[FSIO_TABLE_8] fsioTable2RpmBins;RPM is float and not integer in order to use unified methods for interpolation;"RPM",	   1,      0,      0.0,  25500.0,   2

fsio_table_8x8_u8t fsioTable3;
float[FSIO_TABLE_8] fsioTable3LoadBins;;"L",	   1,      0,      0.0,  255,   0
float[FSIO_TABLE_8] fsioTable3RpmBins;RPM is float and not integer in order to use unified methods for interpolation;"RPM",	   1,      0,      0.0,  25500.0,   2

fsio_table_8x8_u8t fsioTable4;
float[FSIO_TABLE_8] fsioTable4LoadBins;;"L",	   1,      0,      0.0,  255,   0
float[FSIO_TABLE_8] fsioTable4RpmBins;RPM is float and not integer in order to use unified methods for interpolation;"RPM",	   1,      0,      0.0,  25500.0,   2

end_struct

#define MOCK_IAT_COMMAND "mock_iat_voltage"
#define MOCK_CLT_COMMAND "mock_clt_voltage"
#define MOCK_MAP_COMMAND "mock_map_voltage"
#define MOCK_TPS_COMMAND "mock_tps_voltage"
#define MOCK_AFR_COMMAND "mock_afr_voltage"
#define MOCK_MAF_COMMAND "mock_maf_voltage"
! Pedal Position Sensor
#define MOCK_PPS_POSITION_COMMAND "mock_pps_position"
#define MOCK_PPS_VOLTAGE_COMMAND "mock_pps_voltage"


! Live Documentation Structure
#define LDS_CLT_STATE_INDEX 0
#define LDS_IAT_STATE_INDEX 1
#define LDS_SPEED_DENSITY_STATE_INDEX 2
#define LDS_ENGINE_STATE_INDEX 3
#define LDS_FUEL_TRIM_STATE_INDEX 4
#define LDS_TPS_TPS_ENEICHMENT_STATE_INDEX 5
#define LDS_TRIGGER_CENTRAL_STATE_INDEX 6
#define LDS_ETB_PID_STATE_INDEX 7
#define LDS_IDLE_PID_STATE_INDEX 8
#define LDS_ALTERNATOR_PID_STATE_INDEX 9
#define LDS_CJ125_PID_STATE_INDEX 10
#define LDS_TRIGGER_STATE_STATE_INDEX 11



#define GAUGE_NAME_VERSION "firmware"
#define GAUGE_NAME_VVT "VVT position"
#define GAUGE_NAME_TIMING_ADVANCE "timing"
#define GAUGE_NAME_VVS "Vehicle Speed"
#define GAUGE_NAME_VBAT "VBatt"
#define GAUGE_NAME_ENGINE_LOAD "Engine Load"
#define GAUGE_NAME_CPU_TEMP "CPU Temperature"
#define GAUGE_NAME_ETB_TARGET "ETB position target"
#define GAUGE_NAME_ETB_ERROR "ETB position error"
#define GAUGE_NAME_ETB_DUTY "ETB duty cycle"

#define GAUGE_NAME_ACCEL_X "Acceleration: X"
#define GAUGE_NAME_ACCEL_Y "Acceleration: Y"
#define GAUGE_NAME_ACCEL_Z "Acceleration: Z"

#define GAUGE_NAME_ECU_TEMPERATURE "ECU temperature"


#define INDICATOR_NAME_CLUTCH_UP "clutch: up"
#define INDICATOR_NAME_CLUTCH_DOWN "clutch: down"
#define INDICATOR_NAME_BRAKE_DOWN "brake: down"
#define INDICATOR_NAME_AC_SWITCH "AC switch"

#define GAUGE_NAME_AIR_FLOW "air flow"
#define GAUGE_NAME_AIR_MASS "air mass"

#define GAUGE_NAME_WARNING_LAST "warning: last"
#define GAUGE_NAME_WARNING_COUNTER "warning: counter"


#define GAUGE_NAME_KNOCK_LEVEL "knock: current level"
#define GAUGE_NAME_KNOCK_COUNTER "knock: counter"


#define GAUGE_NAME_FUEL_BARO_CORR "fuel: Barometric pressure correction"
#define GAUGE_NAME_THROTTLE_PEDAL "Throttle pedal position"
#define GAUGE_NAME_INJECTOR_LAG "fuel: injector lag"
#define GAUGE_NAME_FUEL_TPS_ROC "fuel: TPS change"
#define GAUGE_NAME_FUEL_CHARGE_TEMP "fuel: Estimated charge temperature"
#define GAUGE_NAME_FUEL_TPS_EXTRA "fuel: TPS acceleration extra fuel ms"
#define GAUGE_NAME_FUEL_EL_EXTRA "fuel: engine load acceleration extra fuel"
#define GAUGE_NAME_FUEL_CLT_CORR "fuel: CLT correction"
#define GAUGE_NAME_FUEL_IAT_CORR "fuel: IAT correction"
#define GAUGE_NAME_FUEL_VE "fuel: VE"
#define GAUGE_NAME_FUEL_CRANKING "fuel: cranking"
#define GAUGE_NAME_FUEL_RUNNING "fuel: running"
#define GAUGE_NAME_FUEL_LAST_INJECTION  "fuel: Last injection"
#define GAUGE_NAME_FUEL_BASE "fuel: base"
#define GAUGE_NAME_FUEL_PID_CORR "fuel: Short-term closed loop correction"
#define GAUGE_NAME_FUEL_WALL_AMOUNT "fuel: wall amount"
#define GAUGE_NAME_FUEL_WALL_CORRECTION "fuel: wall corr ms"

#define GAUGE_NAME_FUEL_INJ_DUTY "fuel: injector duty cycle"
#define GAUGE_NAME_TCHARGE "fuel: SD tCharge"
#define GAUGE_NAME_TARGET_AFR "fuel: target AFR"
#define GAUGE_NAME_AFR "Air/Fuel Ratio"
#define GAUGE_NAME_IAC "Idle Air Valve"

#define GAUGE_NAME_DEBUG_F1 "debug f1"
#define GAUGE_NAME_DEBUG_F2 "debug f2: iTerm"
#define GAUGE_NAME_DEBUG_F3 "debug f3: prevError"
#define GAUGE_NAME_DEBUG_F4 "debug f4: iParam"
#define GAUGE_NAME_DEBUG_F5 "debug f5: dParam"
#define GAUGE_NAME_DEBUG_F6 "debug f6: dTerm"
#define GAUGE_NAME_DEBUG_F7 "debug f7"

#define GAUGE_NAME_DEBUG_I1 "debug i1: pParam"
#define GAUGE_NAME_DEBUG_I2 "debug i2: offset"
#define GAUGE_NAME_DEBUG_I3 "debug i3"
#define GAUGE_NAME_DEBUG_I4 "debug i4"
#define GAUGE_NAME_DEBUG_I5 "debug i5"


#define CMD_PINS "pins"
#define CMD_CALIBRATE_PEDAL_UP "calibrate_pedal_up"
#define CMD_CALIBRATE_PEDAL_DOWN "calibrate_pedal_down"
#define CMD_ETB_DUTY "set_etb_duty"

#define CMD_RESET_ENGINE_SNIFFER "reset_engine_chart"
#define CMD_FUNCTIONAL_TEST_MODE "test_mode"

#define CMD_ENGINE_TYPE "engine_type"
#define CMD_TRIGGERINFO "triggerinfo"
#define CMD_WRITECONFIG "writeconfig"
#define CMD_DATE "date"
#define CMD_REBOOT "reboot"
#define CMD_REBOOT_DFU "reboot_dfu"
#define CMD_ENABLE "enable"
#define CMD_DISABLE "disable"
#define CMD_TRIGGER_HW_INPUT "trigger_hw_input"

#define PROTOCOL_OUTPIN "outpin"
#define PROTOCOL_ANALOG_CHART "analog_chart"
#define PROTOCOL_ENGINE_SNIFFER "wave_chart"
#define PROTOCOL_VERSION_TAG "rusEfiVersion"
#define PROTOCOL_TEST_RESPONSE_TAG "ts_p_alive"

! Engine Sniffer Protocol
#define PROTOCOL_ES_DOWN "d"
#define PROTOCOL_ES_UP "u"
#define TOP_DEAD_CENTER_MESSAGE "r"

! Engine Sniffer channel names
#define PROTOCOL_CRANK1 "t1"
#define PROTOCOL_CRANK2 "t2"
#define PROTOCOL_CRANK3 "t3"

#define PROTOCOL_VVT_NAME "VVT"
#define PROTOCOL_HIP_NAME "HIP"
#define PROTOCOL_TACH_NAME "tach"
#define PROTOCOL_DIZZY_NAME "dizzy"

#define PROTOCOL_WA_CHANNEL_1 "input1"
#define PROTOCOL_WA_CHANNEL_2 "input2"
#define PROTOCOL_WA_CHANNEL_3 "input3"
#define PROTOCOL_WA_CHANNEL_4 "input4"



#define PROTOCOL_COIL1_SHORT_NAME "c1"
#define PROTOCOL_INJ1_SHORT_NAME "i1"

#define GAUGE_NAME_DWELL_DUTY "dwell: coil duty cycle"

#define GAUGE_COIL_DWELL_TIME "dwell: coil charge time"

! some board files override this value using prepend file
#define ts_show_hip9011 true
#define ts_show_cj125 true
#define ts_show_etb true
#define ts_show_etb_pins true
#define ts_show_full_pinout true
#define ts_show_lcd true
#define ts_show_joystick true
#define ts_show_egt true
#define ts_show_gps true

